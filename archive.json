{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2025-02-20T00:56:18.478503+00:00",
  "repo": "ietf-wg-keytrans/draft-protocol",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "documentation",
      "description": "Improvements or additions to documentation",
      "color": "0075ca"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    }
  ],
  "issues": [
    {
      "number": 1,
      "id": "I_kwDOLrnaA86FSxiE",
      "title": "Provide a way to bulk-initialize a log",
      "url": "https://github.com/ietf-wg-keytrans/draft-protocol/issues/1",
      "state": "OPEN",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "There are two aspects to this:\r\n\r\n1. We want to be able to add a certain number of fake entries to hide the actual size of the log.\r\n2. We want to be able to add pre-existing key-value pairs without having one log entry per pair (like we would for key-value pairs added after log creation).\r\n\r\nIt should be very efficient to have a large number of fake prefix tree entries. We also want to not leak the number of real entries that a log starts with",
      "createdAt": "2024-04-10T19:33:46Z",
      "updatedAt": "2024-04-10T19:33:46Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 5,
      "id": "I_kwDOLrnaA86KWbPl",
      "title": "Prefix tree should commit to sets of versions",
      "url": "https://github.com/ietf-wg-keytrans/draft-protocol/issues/5",
      "state": "CLOSED",
      "author": "felixlinker",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Currently, the prefix tree commits to one key-version pair per leaf. I would argue that the leafs should commit to lists of key-version pairs (as the Merkle^2 paper suggests). This way, users can more easily monitor that the server did not include a fake key before to the current epoch.",
      "createdAt": "2024-05-28T13:52:53Z",
      "updatedAt": "2024-05-29T16:31:19Z",
      "closedAt": "2024-05-29T16:31:18Z",
      "comments": [
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm not sure there's any security benefit to having multiple key-version pairs per leaf. It makes things more complicated though, because you have to add an extra step where you are digging into the multiple changes that happened at that one leaf",
          "createdAt": "2024-05-28T16:51:25Z",
          "updatedAt": "2024-05-28T16:51:25Z"
        },
        {
          "author": "felixlinker",
          "authorAssociation": "COLLABORATOR",
          "body": "Brendan and I clarified this issue in a call. My understanding of which indices are used in the prefix tree was wrong.",
          "createdAt": "2024-05-29T16:31:18Z",
          "updatedAt": "2024-05-29T16:31:18Z"
        }
      ]
    }
  ],
  "pulls": [
    {
      "number": 2,
      "id": "PR_kwDOLrnaA85wxAUx",
      "title": "Improvements to hash computation definitions",
      "url": "https://github.com/ietf-wg-keytrans/draft-protocol/pull/2",
      "state": "CLOSED",
      "author": "felixlinker",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Hi Brendan,\r\n\r\nTwo suggestions.\r\n\r\n1. I made the recursion on the hash computation more explicit and gave also leaves the value field. I think this is clearer. The only downside is that you might need to store more information on disk, but the data structures will likely not be implemented like this anyways, no?\r\n2. I dropped that cryptographic computations must be done with the TLS presentation language, because in the algorithms, you reference individual `opaque` fields only anyways. Will this change with the definition of other primitives? Could be. But so far, I thought that this sentence would only falsely lead people to believe that they must use TLS datastructures, ASN.1 parsers, etc., in the library whereas my understanding is that they need not do that.\r\n\r\nCheers!\r\n\r\nFelix",
      "createdAt": "2024-05-28T13:27:51Z",
      "updatedAt": "2024-05-29T16:31:59Z",
      "baseRepository": "ietf-wg-keytrans/draft-protocol",
      "baseRefName": "main",
      "baseRefOid": "9002fc9b5634469fb3cdc4a474532e139ff150d5",
      "headRepository": "felixlinker/draft-keytrans",
      "headRefName": "hashing",
      "headRefOid": "65aba48f82c26aa71a213684475746fe999bf67c",
      "closedAt": "2024-05-29T16:31:58Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "felixlinker",
          "authorAssociation": "COLLABORATOR",
          "body": "Brendan and I discussed this PR in a call. I missed that the TLS data-structures to which I added the `value` field are used elsewhere in cryptographic computations.",
          "createdAt": "2024-05-29T16:31:58Z",
          "updatedAt": "2024-05-29T16:31:58Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOLrnaA858LrU7",
          "commit": {
            "abbreviatedOid": "d2e8b1f"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-28T17:06:39Z",
          "updatedAt": "2024-05-28T17:18:03Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Crypto computations do indeed need to be done in TLS format. TLS specifies endianness, that `opaque` fields are length-prefixed byte strings, etc. Not related to ASN.1. See: https://datatracker.ietf.org/doc/html/rfc5246#section-4",
              "createdAt": "2024-05-28T17:06:40Z",
              "updatedAt": "2024-05-28T17:18:03Z"
            },
            {
              "originalPosition": 16,
              "body": "I don't think it makes sense to store the `value` in the leaf node, as the value can be immediately computed from `key_version`. So it is redundant when this struct is used later on.",
              "createdAt": "2024-05-28T17:13:44Z",
              "updatedAt": "2024-05-28T17:18:03Z"
            },
            {
              "originalPosition": 33,
              "body": "The reason to explicitly say `parent.value = ` is that `value` is an actual field of `PrefixParent` that needs to be populated, potentially stored on-disk. That connection is kind of lost when you roll it into `nodeValue`. And unlike `PrefixLeaf`, `value` can't be computed in isolation",
              "createdAt": "2024-05-28T17:16:11Z",
              "updatedAt": "2024-05-28T17:18:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrnaA858TBHj",
          "commit": {
            "abbreviatedOid": "d2e8b1f"
          },
          "author": "felixlinker",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-29T13:07:33Z",
          "updatedAt": "2024-05-29T13:07:33Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "Is this the level that this spec will operate on? What is stored on disk and what not? This seems like implementation-level details we should not address. Rather, we should address the logic behind the system and have the pseudocode be as understandable as possible. So if leafs have a concept of *value* associated with them, I find it clearer to be explicit about that. Implementors can then apply all nifty tricks to get the size on disk down as much as possible.",
              "createdAt": "2024-05-29T13:07:33Z",
              "updatedAt": "2024-05-29T13:07:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrnaA858TBIw",
          "commit": {
            "abbreviatedOid": "d2e8b1f"
          },
          "author": "felixlinker",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-29T13:07:35Z",
          "updatedAt": "2024-05-29T13:07:35Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "Same as above.",
              "createdAt": "2024-05-29T13:07:35Z",
              "updatedAt": "2024-05-29T13:07:35Z"
            }
          ]
        }
      ]
    },
    {
      "number": 3,
      "id": "PR_kwDOLrnaA85wxLKA",
      "title": "More intuition on tree construction",
      "url": "https://github.com/ietf-wg-keytrans/draft-protocol/pull/3",
      "state": "MERGED",
      "author": "felixlinker",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "With this PR, I try to give a more high-level intuition of what happens in KT, but there is a discrepancy between what I write here (and the Merkle^2 paper) and what you write. I will open an issue separately for that.",
      "createdAt": "2024-05-28T13:48:13Z",
      "updatedAt": "2024-06-02T22:31:48Z",
      "baseRepository": "ietf-wg-keytrans/draft-protocol",
      "baseRefName": "main",
      "baseRefOid": "9002fc9b5634469fb3cdc4a474532e139ff150d5",
      "headRepository": "felixlinker/draft-keytrans",
      "headRefName": "new-intro",
      "headRefOid": "f851f0aa3519c9e2b87fd359e5117531cb35b7b1",
      "closedAt": "2024-06-02T22:31:48Z",
      "mergedAt": "2024-06-02T22:31:48Z",
      "mergedBy": "Bren2010",
      "mergeCommit": {
        "oid": "48f57350664ab9417bd4b2ffb6046c4263b2b9cc"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOLrnaA858Liad",
          "commit": {
            "abbreviatedOid": "4617696"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-28T16:48:04Z",
          "updatedAt": "2024-05-28T16:48:04Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "Maintains two things:\r\n- A log of changes to lookup keys\r\n- A set of key-version pairs",
              "createdAt": "2024-05-28T16:48:04Z",
              "updatedAt": "2024-05-28T16:48:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrnaA858gb9G",
          "commit": {
            "abbreviatedOid": "f88f1db"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-30T17:03:48Z",
          "updatedAt": "2024-05-30T18:05:39Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "```suggestion\r\nservice. To do so, KT maintains two structures: (i) a log of each change to any\r\nkey's value, and (ii) a set containing all of the key-version pairs that have been\r\nlogged. When clients query a KT service, they\r\n```\r\nNo maps. A log and a set",
              "createdAt": "2024-05-30T17:03:49Z",
              "updatedAt": "2024-05-30T18:05:39Z"
            },
            {
              "originalPosition": 20,
              "body": "```suggestion\r\nto both these structures with a *root hash*.\r\n```",
              "createdAt": "2024-05-30T17:06:54Z",
              "updatedAt": "2024-05-30T18:05:39Z"
            },
            {
              "originalPosition": 23,
              "body": "```suggestion\r\nTwo clients which have the same root hash are guaranteed to have the same view\r\nof the tree, and thus would always receive the same result for the same query.\r\n```",
              "createdAt": "2024-05-30T17:07:59Z",
              "updatedAt": "2024-05-30T18:05:39Z"
            },
            {
              "originalPosition": 27,
              "body": "```suggestion\r\nprefix trees. The log tree commits to (i) and \r\nthe prefix tree commits to (ii). This section describes the operation of\r\n```",
              "createdAt": "2024-05-30T17:09:24Z",
              "updatedAt": "2024-05-30T18:05:39Z"
            },
            {
              "originalPosition": 34,
              "body": "```suggestion\r\nBoth types of trees consist of\r\n*nodes* which have a byte string as their *hash value*. A node is either a\r\n*leaf* if it has no children, or a *parent*\r\n```",
              "createdAt": "2024-05-30T17:22:04Z",
              "updatedAt": "2024-05-30T18:05:39Z"
            },
            {
              "originalPosition": 49,
              "body": "```suggestion\r\nwas added and are constructed as *left-balanced* binary trees.\r\n```\r\nSaying what the values of the leaves are is getting ahead of yourself. Don't need to discuss leaf values until we get to Combined Tree",
              "createdAt": "2024-05-30T17:51:54Z",
              "updatedAt": "2024-05-30T18:05:39Z"
            },
            {
              "originalPosition": 60,
              "body": "```suggestion\r\nLog trees initially consist of a single leaf node. New leaves are\r\n```",
              "createdAt": "2024-05-30T17:52:51Z",
              "updatedAt": "2024-05-30T18:05:40Z"
            },
            {
              "originalPosition": 70,
              "body": "```suggestion\r\nWhile leaves contain arbitrary data, the value of a parent node is always the\r\nhash of the combined values of its left and right children.\r\n```\r\nImo the previous text is clearer",
              "createdAt": "2024-05-30T17:54:29Z",
              "updatedAt": "2024-05-30T18:05:40Z"
            },
            {
              "originalPosition": 87,
              "body": "When doing little changes, it keeps the diff cleaner to not rewrap text. Don't need to undo wraps in this PR, just saying for future",
              "createdAt": "2024-05-30T17:55:12Z",
              "updatedAt": "2024-05-30T18:05:40Z"
            },
            {
              "originalPosition": 177,
              "body": "```suggestion\r\nmaintains the set of index-version pairs. Importantly, the root hash value of the\r\nprefix tree after adding a new index-version pair is stored in a leaf of the log\r\n```\r\nNeed to use index consistently, not pseudonym",
              "createdAt": "2024-05-30T18:02:15Z",
              "updatedAt": "2024-05-30T18:05:40Z"
            },
            {
              "originalPosition": 123,
              "body": "```suggestion\r\nleft child if the first bit of a value is 0, or the right child if the first\r\n```\r\n\"Prefix tree is used for storing a set of values\" so sticking with value",
              "createdAt": "2024-05-30T18:03:50Z",
              "updatedAt": "2024-05-30T18:05:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrnaA858m21G",
          "commit": {
            "abbreviatedOid": "f88f1db"
          },
          "author": "felixlinker",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-31T11:03:36Z",
          "updatedAt": "2024-05-31T11:03:36Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "I think it's important to point out how the leafs of each tree are addressed. For (i), it's by a global version counter (actually, we should find a name for this; is there one?). For (ii), it's the output of the VRF for pseudonym + local version counter. I find this very important! A set cannot be indexed, yet we will index the trees.",
              "createdAt": "2024-05-31T11:03:36Z",
              "updatedAt": "2024-05-31T11:03:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrnaA858m5NN",
          "commit": {
            "abbreviatedOid": "f88f1db"
          },
          "author": "felixlinker",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-31T11:06:27Z",
          "updatedAt": "2024-05-31T11:06:27Z",
          "comments": [
            {
              "originalPosition": 49,
              "body": "I think it's important to provide intuitions as early as possible. Here one could say that an intuition was already provided in the introduction of the combined tree structure earlier, but readers who skip between sections might miss this.",
              "createdAt": "2024-05-31T11:06:27Z",
              "updatedAt": "2024-05-31T11:06:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrnaA858m5qe",
          "commit": {
            "abbreviatedOid": "f88f1db"
          },
          "author": "felixlinker",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-31T11:07:41Z",
          "updatedAt": "2024-05-31T11:07:41Z",
          "comments": [
            {
              "originalPosition": 70,
              "body": "Some complications arise from refactoring \"value\" into \"hash value\" and this is one of them. It was clearer before, but if we want to distinguish \"hash value\" from \"value\" (which I think we should), I'd rather be explicit here.",
              "createdAt": "2024-05-31T11:07:41Z",
              "updatedAt": "2024-05-31T11:07:41Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrnaA858m6Gz",
          "commit": {
            "abbreviatedOid": "f88f1db"
          },
          "author": "felixlinker",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-31T11:08:55Z",
          "updatedAt": "2024-05-31T11:08:55Z",
          "comments": [
            {
              "originalPosition": 87,
              "body": "Do you have any preference regarding how we handle formatting? When would you like to enforce the 80 characters limit?",
              "createdAt": "2024-05-31T11:08:55Z",
              "updatedAt": "2024-05-31T11:08:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrnaA858p9Ov",
          "commit": {
            "abbreviatedOid": "f88f1db"
          },
          "author": "felixlinker",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-31T17:28:28Z",
          "updatedAt": "2024-05-31T17:28:28Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "Okay, one could make the case that the indexing of the log is implicit. The position of the leaf determines its index. But since we will use the index-terminology anyways, I think it's clearer to say that both types of trees commit to an index-value store and are optimized for different kinds of proofs.",
              "createdAt": "2024-05-31T17:28:28Z",
              "updatedAt": "2024-05-31T17:28:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrnaA858unmG",
          "commit": {
            "abbreviatedOid": "286578b"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-06-02T19:29:54Z",
          "updatedAt": "2024-06-02T22:30:48Z",
          "comments": [
            {
              "originalPosition": 70,
              "body": "We should distinguish hash value from value. But in this text, we're talking about value. Talking about hash value adds an extra layer to understand",
              "createdAt": "2024-06-02T19:29:54Z",
              "updatedAt": "2024-06-02T22:30:48Z"
            },
            {
              "originalPosition": 87,
              "body": "When writing new text, 80 chars is good. When modifying existing text, the goal is to have a clear diff, so it's fine if lines end up uneven lengths",
              "createdAt": "2024-06-02T19:32:39Z",
              "updatedAt": "2024-06-02T22:30:48Z"
            },
            {
              "originalPosition": 95,
              "body": "```suggestion\r\nto efficiently produce proofs of membership and non-membership in the set.\r\n\r\nEach leaf node in a prefix tree represents a specific value, while each parent\r\nnode represents some prefix which all values in the subtree headed by that node\r\nhave in common. The subtree headed by a parent's left child contains all values\r\nthat share its prefix followed by an additional 0 bit, while the subtree headed\r\nby a parent's right child contains all values that share its prefix followed by\r\nan additional 1 bit.\r\n\r\nThe root node, in particular, represents the empty string as a prefix. The\r\nroot's left child contains all values that begin with a 0 bit, while the right\r\nchild contains all values that begin with a 1 bit.\r\n```",
              "createdAt": "2024-06-02T22:27:12Z",
              "updatedAt": "2024-06-02T22:30:48Z"
            },
            {
              "originalPosition": 122,
              "body": "```suggestion\r\nNew values are added to the tree by searching it according to the same process.\r\nIf the search terminates at a parent without a left or right child, a new leaf\r\nis simply added as the parent's missing child. If the search terminates at a\r\nleaf for the wrong value, one or more intermediate nodes are added until the new\r\nleaf and the existing leaf would no longer reside in the same place. That is,\r\nuntil we reach the first bit that differs between the new value and the existing\r\nvalue.\r\n```",
              "createdAt": "2024-06-02T22:28:33Z",
              "updatedAt": "2024-06-02T22:30:48Z"
            },
            {
              "originalPosition": 105,
              "body": "```suggestion\r\nleft child if the first bit of a value is 0, or the right child if the first bit\r\nis 1. This is then repeated for the second bit, third bit, and so on until the\r\nsearch either terminates at a leaf node (which may or may not be for the desired\r\nvalue), or a parent node that lacks the desired child.\r\n```",
              "createdAt": "2024-06-02T22:28:51Z",
              "updatedAt": "2024-06-02T22:30:48Z"
            },
            {
              "originalPosition": 131,
              "body": "```suggestion\r\nThe value of a leaf node is the encoded set member, while the value of a\r\nparent node is the hash of the combined values of its left and right children\r\n(or a stand-in value when one of the children doesn't exist).\r\n```",
              "createdAt": "2024-06-02T22:30:21Z",
              "updatedAt": "2024-06-02T22:30:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrnaA858usld",
          "commit": {
            "abbreviatedOid": "f851f0a"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-06-02T22:31:38Z",
          "updatedAt": "2024-06-02T22:31:38Z",
          "comments": []
        }
      ]
    },
    {
      "number": 4,
      "id": "PR_kwDOLrnaA85wxL1V",
      "title": "Add Felix Linker as author",
      "url": "https://github.com/ietf-wg-keytrans/draft-protocol/pull/4",
      "state": "MERGED",
      "author": "felixlinker",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-05-28T13:49:24Z",
      "updatedAt": "2024-05-28T16:43:37Z",
      "baseRepository": "ietf-wg-keytrans/draft-protocol",
      "baseRefName": "main",
      "baseRefOid": "9002fc9b5634469fb3cdc4a474532e139ff150d5",
      "headRepository": "felixlinker/draft-keytrans",
      "headRefName": "authorship",
      "headRefOid": "8ad7441a4043593e8bec351c3c8762d5ec4634c5",
      "closedAt": "2024-05-28T16:43:37Z",
      "mergedAt": "2024-05-28T16:43:37Z",
      "mergedBy": "Bren2010",
      "mergeCommit": {
        "oid": "610128224a781e017d916a5ed19b4b5be57ac5a3"
      },
      "comments": [
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "Feel free to add an organization as well if you'd like",
          "createdAt": "2024-05-28T16:43:32Z",
          "updatedAt": "2024-05-28T16:43:32Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 6,
      "id": "PR_kwDOLrnaA85xhltE",
      "title": "Figures",
      "url": "https://github.com/ietf-wg-keytrans/draft-protocol/pull/6",
      "state": "MERGED",
      "author": "felixlinker",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-06-05T09:21:57Z",
      "updatedAt": "2024-06-06T03:46:29Z",
      "baseRepository": "ietf-wg-keytrans/draft-protocol",
      "baseRefName": "main",
      "baseRefOid": "48f57350664ab9417bd4b2ffb6046c4263b2b9cc",
      "headRepository": "felixlinker/draft-keytrans",
      "headRefName": "diagrams",
      "headRefOid": "729b821e90cabf8340da1916266e47b79e6e53e1",
      "closedAt": "2024-06-06T03:46:29Z",
      "mergedAt": "2024-06-06T03:46:29Z",
      "mergedBy": "Bren2010",
      "mergeCommit": {
        "oid": "6e3f4698a915eca9f97575b524bb2e50e4f4b87a"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOLrnaA859Ns2r",
          "commit": {
            "abbreviatedOid": "729b821"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thank you!!",
          "createdAt": "2024-06-06T03:46:15Z",
          "updatedAt": "2024-06-06T03:46:15Z",
          "comments": []
        }
      ]
    },
    {
      "number": 7,
      "id": "PR_kwDOLrnaA85xkYLF",
      "title": "Editing",
      "url": "https://github.com/ietf-wg-keytrans/draft-protocol/pull/7",
      "state": "MERGED",
      "author": "felixlinker",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-06-05T14:59:28Z",
      "updatedAt": "2024-06-17T17:00:20Z",
      "baseRepository": "ietf-wg-keytrans/draft-protocol",
      "baseRefName": "main",
      "baseRefOid": "7ed4d53c2869595022acb9fe583fb30ecec427f9",
      "headRepository": "felixlinker/draft-keytrans",
      "headRefName": "editing",
      "headRefOid": "c3b8c7acbc34af133369a7a23d7192c8155618c6",
      "closedAt": "2024-06-17T17:00:20Z",
      "mergedAt": "2024-06-17T17:00:20Z",
      "mergedBy": "Bren2010",
      "mergeCommit": {
        "oid": "e7661dd33f5f327cc2a9afed6d2069904580b98e"
      },
      "comments": [
        {
          "author": "felixlinker",
          "authorAssociation": "COLLABORATOR",
          "body": "@Bren2010 I refactored \"pseudonym\" and \"search key\" into \"label\" and tried providing more intuition in the intro of the \"Searching the Tree\" section.\r\n\r\nI think we need both terms \"index\" and \"label\". For example, we counter for the leafs of the log tree also \"index\". This makes sense. I would say: \"index\" means the thing you _index_ a tree by, i.e., VRF-output or log-tree counter, and \"label\" means the thing you associate keys with, e.g., pseudonyms.\r\n\r\nCurrently, we don't define \"index\" but only use it implicitly. I don't think this is too bad right now, but could be improved.\r\n\r\nPR is ready for review and merge!",
          "createdAt": "2024-06-11T09:13:41Z",
          "updatedAt": "2024-06-11T09:13:41Z"
        },
        {
          "author": "felixlinker",
          "authorAssociation": "COLLABORATOR",
          "body": "@Bren2010 Addressed your comment on key updates and rebased onto main!",
          "createdAt": "2024-06-17T07:54:25Z",
          "updatedAt": "2024-06-17T07:54:25Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOLrnaA85-MCuN",
          "commit": {
            "abbreviatedOid": "0de4cb2"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Also does unfortunately need to be rebased",
          "createdAt": "2024-06-13T21:45:45Z",
          "updatedAt": "2024-06-14T04:35:02Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Here it seems you're using \"key\" as an abbreviation for \"public key\". Is that right? Public keys will not be the only things stored in a KT log. Labels may map to other labels, to arbitrary structured data, etc",
              "createdAt": "2024-06-13T21:45:45Z",
              "updatedAt": "2024-06-14T04:35:02Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrnaA85-fVNh",
          "commit": {
            "abbreviatedOid": "0de4cb2"
          },
          "author": "felixlinker",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-06-17T07:48:33Z",
          "updatedAt": "2024-06-17T07:48:33Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Correct. \"Key\" is supposed to mean \"public key.\" What you are saying is correct, but I think that my phrasing is accurate as I say that \"keys are associated with labels\" not \"labels map to keys.\"\r\n\r\nI clarified what \"key updates\" are now a bit bellow to avoid confusion! (See most recent commit.)",
              "createdAt": "2024-06-17T07:48:33Z",
              "updatedAt": "2024-06-17T07:48:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrnaA85-kN6K",
          "commit": {
            "abbreviatedOid": "c3b8c7a"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-06-17T17:00:14Z",
          "updatedAt": "2024-06-17T17:00:14Z",
          "comments": []
        }
      ]
    },
    {
      "number": 8,
      "id": "PR_kwDOLrnaA853Rzu0",
      "title": "Editing",
      "url": "https://github.com/ietf-wg-keytrans/draft-protocol/pull/8",
      "state": "MERGED",
      "author": "felixlinker",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I hope text is self-explanatory! :) Some of the changes are more straight-forward than others. If you want, we can split the PR up.",
      "createdAt": "2024-08-02T16:29:26Z",
      "updatedAt": "2024-08-22T07:35:23Z",
      "baseRepository": "ietf-wg-keytrans/draft-protocol",
      "baseRefName": "main",
      "baseRefOid": "e7661dd33f5f327cc2a9afed6d2069904580b98e",
      "headRepository": "ietf-wg-keytrans/draft-protocol",
      "headRefName": "editing",
      "headRefOid": "8d214c801ea825cc3bbf9d3822d0eaa05768dfc3",
      "closedAt": "2024-08-02T16:30:53Z",
      "mergedAt": "2024-08-02T16:30:53Z",
      "mergedBy": "felixlinker",
      "mergeCommit": {
        "oid": "8d214c801ea825cc3bbf9d3822d0eaa05768dfc3"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 9,
      "id": "PR_kwDOLrnaA855FzDL",
      "title": "Add aasvg dependency",
      "url": "https://github.com/ietf-wg-keytrans/draft-protocol/pull/9",
      "state": "MERGED",
      "author": "felixlinker",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Commit does the same as suggested here: https://github.com/ietf-wg-scitt/draft-ietf-scitt-architecture/pull/142\r\n\r\nWith the change, I can run `make` locally to preview changes, see warnings, etc.",
      "createdAt": "2024-08-22T08:13:52Z",
      "updatedAt": "2024-10-10T13:43:26Z",
      "baseRepository": "ietf-wg-keytrans/draft-protocol",
      "baseRefName": "main",
      "baseRefOid": "6daf33c8233a81fa57093289fb2a08a176a13ac6",
      "headRepository": "ietf-wg-keytrans/draft-protocol",
      "headRefName": "package-json",
      "headRefOid": "741acb77637651d7088bededd4288a5044875d80",
      "closedAt": "2024-09-13T04:07:23Z",
      "mergedAt": "2024-09-13T04:07:23Z",
      "mergedBy": "Bren2010",
      "mergeCommit": {
        "oid": "12f569da33954320c48045bfb5f629e54774a55e"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOLrnaA86GZrfs",
          "commit": {
            "abbreviatedOid": "741acb7"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-08-22T15:15:14Z",
          "updatedAt": "2024-08-22T15:15:14Z",
          "comments": []
        }
      ]
    },
    {
      "number": 10,
      "id": "PR_kwDOLrnaA85-PNV6",
      "title": "First step towards third-party auditing",
      "url": "https://github.com/ietf-wg-keytrans/draft-protocol/pull/10",
      "state": "MERGED",
      "author": "felixlinker",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I started writing about third-party auditing. The PR is not complete yet, but I wanted to iterate early on! Especially curious to hear what you think about the TLS encoding.\r\n\r\nWould be great to hear whether you think this goes in the right direction!",
      "createdAt": "2024-10-10T15:05:25Z",
      "updatedAt": "2024-10-11T02:44:45Z",
      "baseRepository": "ietf-wg-keytrans/draft-protocol",
      "baseRefName": "main",
      "baseRefOid": "12f569da33954320c48045bfb5f629e54774a55e",
      "headRepository": "ietf-wg-keytrans/draft-protocol",
      "headRefName": "tp-auditing",
      "headRefOid": "ce7ad760b27ddb560101df394a7affdcbce99073",
      "closedAt": "2024-10-11T02:44:45Z",
      "mergedAt": "2024-10-11T02:44:45Z",
      "mergedBy": "Bren2010",
      "mergeCommit": {
        "oid": "d71426e84c54e5c44455323c95b1f3b732ce1ccd"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 11,
      "id": "PR_kwDOLrnaA85-Stzw",
      "title": "Introduce idea of full vs abridged search proofs",
      "url": "https://github.com/ietf-wg-keytrans/draft-protocol/pull/11",
      "state": "MERGED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-10-11T02:43:23Z",
      "updatedAt": "2024-10-11T02:44:27Z",
      "baseRepository": "ietf-wg-keytrans/draft-protocol",
      "baseRefName": "tp-auditing",
      "baseRefOid": "35270e19711da2e3b2839da67c1cda25cc3ccda0",
      "headRepository": "ietf-wg-keytrans/draft-protocol",
      "headRefName": "brendan/tp-editorial",
      "headRefOid": "ea42541b18205e0325ef714303005a0f80afba26",
      "closedAt": "2024-10-11T02:44:27Z",
      "mergedAt": "2024-10-11T02:44:27Z",
      "mergedBy": "Bren2010",
      "mergeCommit": {
        "oid": "ce7ad760b27ddb560101df394a7affdcbce99073"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 12,
      "id": "PR_kwDOLrnaA86FtSCc",
      "title": "Support for strong authentication of time",
      "url": "https://github.com/ietf-wg-keytrans/draft-protocol/pull/12",
      "state": "MERGED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "- The main change here is to have each log entry contain the time it was created. This provides a stronger authentication of time compared to just signing it into the tree head and prevents certain classes of attacks.\r\n- Introduces the concept of a \"maximum lifetime\" for log entries. Essentially, if a log entry is too old, users will be able to see that and guide their search away from old portions of the tree, allowing them to be pruned.\r\n- Introduces the concept of a \"reasonable monitoring window\". This is the opposite of the \"maximum lifetime\" idea -- it allows users to tell when certain log entries have been added so recently that other users likely haven't had time to vet their contents. When users see that information has been added within the reasonable monitoring window, they maintain extra state about it to prevent/detect potential attacks. Similarly, when information is older than the reasonable monitoring window, it is taken more at face value.",
      "createdAt": "2024-12-18T23:02:49Z",
      "updatedAt": "2025-01-28T17:35:05Z",
      "baseRepository": "ietf-wg-keytrans/draft-protocol",
      "baseRefName": "main",
      "baseRefOid": "a610396bea5711d8c2975d2c4f41402c6a249d88",
      "headRepository": "ietf-wg-keytrans/draft-protocol",
      "headRefName": "brendan/time2",
      "headRefOid": "09620ce4f334505aa421236e9c62b916c21ff6a6",
      "closedAt": "2025-01-28T17:35:04Z",
      "mergedAt": "2025-01-28T17:35:04Z",
      "mergedBy": "Bren2010",
      "mergeCommit": {
        "oid": "115d6722d02f56beaf3acefa0504b2c9dc9545de"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOLrnaA86WpGrs",
          "commit": {
            "abbreviatedOid": "bc7098f"
          },
          "author": "thibmeu",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "this is a great addition. I have done a read, not an implementation. only minor comment, no blocker",
          "createdAt": "2025-01-02T10:45:30Z",
          "updatedAt": "2025-01-02T11:03:15Z",
          "comments": [
            {
              "originalPosition": 128,
              "body": "maybe point to the timestamp definition which appears much later in the document: Unix epoch in milliseconds.",
              "createdAt": "2025-01-02T10:45:30Z",
              "updatedAt": "2025-01-02T11:03:15Z"
            },
            {
              "originalPosition": 238,
              "body": "this is a great addition for readability",
              "createdAt": "2025-01-02T10:45:59Z",
              "updatedAt": "2025-01-02T11:03:15Z"
            },
            {
              "originalPosition": 281,
              "body": "consider aligning the wording with the `Configuration` defined below\r\n```\r\n  uint64 max_ahead;\r\n  unit64 max_behind;\r\n  uint64 reasonable_monitoring_window;\r\n  optional<uint64> maximum_lifetime;\r\n```\r\n\r\nfor instance, `how old of a view of` -> `how far behind`",
              "createdAt": "2025-01-02T10:49:10Z",
              "updatedAt": "2025-01-02T11:03:15Z"
            },
            {
              "originalPosition": 804,
              "body": "Unix epoch?",
              "createdAt": "2025-01-02T10:58:18Z",
              "updatedAt": "2025-01-02T11:03:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrnaA86XwGLf",
          "commit": {
            "abbreviatedOid": "bc7098f"
          },
          "author": "felixlinker",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "I like the changes and think they're a great addition. I have left some comments, but they are all on details.",
          "createdAt": "2025-01-13T08:20:18Z",
          "updatedAt": "2025-01-13T12:29:22Z",
          "comments": [
            {
              "originalPosition": 217,
              "body": "I find it unclear what \"the result\" exactly refers to here.",
              "createdAt": "2025-01-13T08:20:18Z",
              "updatedAt": "2025-01-13T12:29:22Z"
            },
            {
              "originalPosition": 251,
              "body": "Suggestion to replace the \"The full subtrees...\" sentence:\r\n> Full subtrees are the largest subtrees with size $2^n-1$ for some $n$.\r\n\r\nAs you define it now, a full subtree has all its subtrees as full subtrees too. I guess you don't want that.",
              "createdAt": "2025-01-13T08:24:42Z",
              "updatedAt": "2025-01-13T12:29:22Z"
            },
            {
              "originalPosition": 246,
              "body": "Unclear to me: What state does the user track overall? Here you say: \"about the last tree head they've observed.\" It might be more clear to say:\r\n> Clients retain the last tree head they've observed alongside some metadata, namely: [...]\r\n\r\nThis would make it clearer that this is all the user stores. (Additionally, I distinguished between client and user. But not sure you want that language.)",
              "createdAt": "2025-01-13T08:28:03Z",
              "updatedAt": "2025-01-13T12:29:22Z"
            },
            {
              "originalPosition": 264,
              "body": "```suggestion\r\n  direct path in the new implicit binary search tree.\r\n```",
              "createdAt": "2025-01-13T08:44:14Z",
              "updatedAt": "2025-01-13T12:29:22Z"
            },
            {
              "originalPosition": 380,
              "body": "I would break the paragraph before the \"However.\" I missed the last sentence when first reading the paragraph. I took the paragraph as \"example of how the binary ladder works,\" but the last sentence changes topic. That can be confusing.",
              "createdAt": "2025-01-13T08:51:10Z",
              "updatedAt": "2025-01-13T12:29:22Z"
            },
            {
              "originalPosition": 393,
              "body": "I don't get this. Reads like \"log omits proofs of inclusion [...] where proof of inclusion was already provided.\" Does it omit it or not? Or do you mean that you don't repeat proofs? (One query could contain queries for multiple versions or something similar.)",
              "createdAt": "2025-01-13T08:53:54Z",
              "updatedAt": "2025-01-13T12:29:22Z"
            },
            {
              "originalPosition": 396,
              "body": "I'm not sure whether this explanation adds much. It basically says \"it's fine,\" but doesn't say why. That's not a problem, but maybe saying nothing is better.",
              "createdAt": "2025-01-13T08:54:43Z",
              "updatedAt": "2025-01-13T12:29:22Z"
            },
            {
              "originalPosition": 410,
              "body": "\"Root log entry\" w.r.t. implicit binary search tree? If so, wouldn't it be more simple to say: \"The user may encounter expired log entries when searching the implicit binary search tree\"? Captures both cases. Is it necessary to distinguish root/not-root?",
              "createdAt": "2025-01-13T08:55:44Z",
              "updatedAt": "2025-01-13T12:29:22Z"
            },
            {
              "originalPosition": 425,
              "body": "Similarly to my comment above, it seems like one should be able to generalize the algorithm for both cases. It seems like its something along the lines of:\r\n```py\r\ndef recurse_search(node, search_target):\r\n  if node.matches(search_target):\r\n    return node\r\n  elif node.continue_right(search_target):\r\n    return recurse_search(node.right, search_target)\r\n  else:  # continue left\r\n    if node.expired:\r\n      throw ExpiredError()\r\n    else:\r\n      return recurse_search(node.left, search_target)\r\n```",
              "createdAt": "2025-01-13T09:01:54Z",
              "updatedAt": "2025-01-13T12:29:22Z"
            },
            {
              "originalPosition": 456,
              "body": "I don't understand what \"short of\" means here. Sentence seems clear without that.",
              "createdAt": "2025-01-13T09:09:08Z",
              "updatedAt": "2025-01-13T12:29:22Z"
            },
            {
              "originalPosition": 462,
              "body": "I think the \"largely\" is confusing here. Does it conclude the search or not? I would suggest to say something like:\r\n> Before returning the result, the client must also check some side-conditions, which are [...].",
              "createdAt": "2025-01-13T09:12:27Z",
              "updatedAt": "2025-01-13T12:29:22Z"
            },
            {
              "originalPosition": 461,
              "body": "Seems like there's something missing here.",
              "createdAt": "2025-01-13T09:14:09Z",
              "updatedAt": "2025-01-13T12:29:22Z"
            },
            {
              "originalPosition": 472,
              "body": "How can a binary ladder ever skip the target version?",
              "createdAt": "2025-01-13T09:15:16Z",
              "updatedAt": "2025-01-13T12:29:22Z"
            },
            {
              "originalPosition": 481,
              "body": "```suggestion\r\nentry that contains the target label-version pair. The purpose of\r\n```",
              "createdAt": "2025-01-13T09:16:53Z",
              "updatedAt": "2025-01-13T12:29:22Z"
            },
            {
              "originalPosition": 532,
              "body": "Why does the standard not suggest an algorithm to choose a distinguished log entry? Also, it's unclear to me whether distinguished log entries are defined per client or log and per label or globally.\r\n\r\nPS: Aha. Comes below. Maybe point out here that this will be defined next.\r\n\r\nPPS: From reading the algorithm below, I take that distinguished log entries are defined per log.",
              "createdAt": "2025-01-13T09:27:00Z",
              "updatedAt": "2025-01-13T12:29:22Z"
            },
            {
              "originalPosition": 570,
              "body": "```suggestion\r\nThe algorithm is initially called with these parameters: the\r\n```",
              "createdAt": "2025-01-13T09:33:44Z",
              "updatedAt": "2025-01-13T12:29:22Z"
            },
            {
              "originalPosition": 573,
              "body": "I think it would be clearer to move this before the algorithm definition above. For example, taking the difference in step 2 above and comparing that to RMW wasn't initially sensible to me. It makes sense now that I know you basically start with the difference being the log's lifetime.",
              "createdAt": "2025-01-13T09:34:24Z",
              "updatedAt": "2025-01-13T12:29:22Z"
            },
            {
              "originalPosition": 559,
              "body": "_Technically_, \"right/left timestamp\" is undefined. You defined \"timestamp of a log entry to its left/right.\" Could be taken as right/left timestamp of the log entry's respective children.",
              "createdAt": "2025-01-13T09:35:28Z",
              "updatedAt": "2025-01-13T12:29:22Z"
            },
            {
              "originalPosition": 568,
              "body": "I don't understand these two steps. Isn't the implicit binary search tree balanced s.t. if a node has a right child, it will also have a left child? If that is the case, doesn't this algorithm simply go to the left-most leaf?\r\n\r\nPS: Okay. I think I get it now. \"Assert\" means you basically create a list of distinguished entries. I took steps 3. and 4. as \"return recurse(...)\". It might make sense to make it explicit that this creates a list of distinguished log entries.",
              "createdAt": "2025-01-13T09:38:09Z",
              "updatedAt": "2025-01-13T12:29:22Z"
            },
            {
              "originalPosition": 560,
              "body": "I think \"assert\" is a confusing word as I take it to mean \"check.\" (As an assert in C++.) But if you agree with my comment below, I guess this will be changed anyways.",
              "createdAt": "2025-01-13T09:41:53Z",
              "updatedAt": "2025-01-13T12:29:22Z"
            },
            {
              "originalPosition": 592,
              "body": "I think this could be linked more clearly to the introduction of the monitoring section. Could be pointed out that this algorithm is intended to be run by non-owners to check that the server doesn't conceal what they've shown the user.",
              "createdAt": "2025-01-13T09:53:57Z",
              "updatedAt": "2025-01-13T12:29:22Z"
            },
            {
              "originalPosition": 626,
              "body": "I would say it *is* equivalent and thus shouldn't be repeated. I think you defined this as a fixed-version search. So why re-explain it here?",
              "createdAt": "2025-01-13T09:59:18Z",
              "updatedAt": "2025-01-13T12:29:22Z"
            },
            {
              "originalPosition": 291,
              "body": "I think it's a bit confusing to name this section \"Fixed-Version Searches\" when the \"Binary Ladder\" section below first defines the binary ladder in terms of searching for the most recent version of a label. Alternatively, you could call this section \"Version Searches\" and then provide two algorithms for fixed- and greatest-version search. I think the latter suggestion would be clearer as greatest-version search now sits between fixed-version search and monitoring. Why this split?\r\n\r\nPS: Aha. After having read Greatest-Version Search, I understand why the split. Nevertheless, I think it would make sense to rewrite the binary ladder section from the point of view of fixed-version search and make greatest-version search the exception.",
              "createdAt": "2025-01-13T10:02:40Z",
              "updatedAt": "2025-01-13T12:29:22Z"
            },
            {
              "originalPosition": 669,
              "body": "```suggestion\r\n1. Determine if the log entry is distinguished. If so, leave\r\n```",
              "createdAt": "2025-01-13T10:05:47Z",
              "updatedAt": "2025-01-13T12:29:22Z"
            },
            {
              "originalPosition": 671,
              "body": "```suggestion\r\n2. Compute the log entry's direct path in the implicit binary search\r\n```",
              "createdAt": "2025-01-13T10:06:13Z",
              "updatedAt": "2025-01-13T12:29:22Z"
            },
            {
              "originalPosition": 674,
              "body": "Terminate which list?",
              "createdAt": "2025-01-13T10:07:06Z",
              "updatedAt": "2025-01-13T12:29:22Z"
            },
            {
              "originalPosition": 675,
              "body": "Again: What list? (Skipping the rest. I'm a bit lost.)",
              "createdAt": "2025-01-13T10:07:27Z",
              "updatedAt": "2025-01-13T12:29:22Z"
            },
            {
              "originalPosition": 726,
              "body": "Unclear: the greatest version of the label _per subsequent distinguished log entry_? I presume so, but not explicit.",
              "createdAt": "2025-01-13T10:56:05Z",
              "updatedAt": "2025-01-13T12:29:22Z"
            },
            {
              "originalPosition": 736,
              "body": "```suggestion\r\nreceive a binary ladder for all distinguished log entries following the one\r\nthey've advertised. The Transparency Log provides whichever intermediate\r\n```",
              "createdAt": "2025-01-13T10:57:55Z",
              "updatedAt": "2025-01-13T12:29:22Z"
            },
            {
              "originalPosition": 763,
              "body": "Doesn't this contradict what is written in Binary Ladder? There, you get the full binary ladder.",
              "createdAt": "2025-01-13T11:32:32Z",
              "updatedAt": "2025-01-13T12:29:22Z"
            },
            {
              "originalPosition": 764,
              "body": "```suggestion\r\ngreatest version as the target in the rightmost distinguished log entry the root\r\nif there is no distinguished log entry yet.\r\n```\r\n\r\nFind this clearer as \"the search\" was ambiguous. (Prefix tree search (=binary ladder) or log tree search?)",
              "createdAt": "2025-01-13T11:34:43Z",
              "updatedAt": "2025-01-13T12:29:22Z"
            },
            {
              "originalPosition": 801,
              "body": "Doesn't really matter, but could also be seconds. I guess client/server clocks will not be sufficiently synchronized s.t. milliseconds can ever become relevant.",
              "createdAt": "2025-01-13T11:36:27Z",
              "updatedAt": "2025-01-13T12:29:22Z"
            },
            {
              "originalPosition": 1043,
              "body": "This sounds like `|timestampes| = |prefix_proofs| + |prefix_roots|`. If so, would it be an option to reflect that in the type? The `CombinedTreeProof` could be an array of structs where each struct has timestamp, and a prefix proof or a prefix root as an or type. Don't know whether the data language permits OR-types, though.\r\n\r\nPS: Aha. Okay. Doesn't seem like that. Seems like `|timestampes| < |prefix_proofs| + |prefix_roots|`.",
              "createdAt": "2025-01-13T11:48:57Z",
              "updatedAt": "2025-01-13T12:29:22Z"
            },
            {
              "originalPosition": 1052,
              "body": "What does it mean to \"have an entry in `prefix_proofs`\"? Not quite clear to me.",
              "createdAt": "2025-01-13T11:51:15Z",
              "updatedAt": "2025-01-13T12:29:22Z"
            },
            {
              "originalPosition": 1054,
              "body": "Hm. So repeated prefix proofs are identical. But why not repeat timestamps then, too?",
              "createdAt": "2025-01-13T11:51:56Z",
              "updatedAt": "2025-01-13T12:29:22Z"
            },
            {
              "originalPosition": 1087,
              "body": "```suggestion\r\n  - Otherwise, if the log entry's right child has also surpassed its\r\n    maximum lifetime, then a `PrefixProof` corresponding to a binary ladder in\r\n```\r\n\r\nSeems clearer to me this way as it's explicit that bullet point 3 is the else branch of bullet point 2.",
              "createdAt": "2025-01-13T11:58:17Z",
              "updatedAt": "2025-01-13T12:29:22Z"
            },
            {
              "originalPosition": 1089,
              "body": "```suggestion\r\n- If the `PrefixProof` from the first log entry containing the label-version\r\n```",
              "createdAt": "2025-01-13T11:59:06Z",
              "updatedAt": "2025-01-13T12:29:22Z"
            },
            {
              "originalPosition": 1090,
              "body": "What does \"the label-version pair\" refer to? The target? And what does \"touch\" mean? Doesn't every prefix proof \"touch\" the target as in it shows inclusion/non-inclusion?",
              "createdAt": "2025-01-13T12:00:26Z",
              "updatedAt": "2025-01-13T12:29:22Z"
            },
            {
              "originalPosition": 1211,
              "body": "I don't understand why there is a single binary ladder here. Don't we need multiple (for each node on the path in the implicit binary search tree to the leaf)? And aren't those provided in `search`?",
              "createdAt": "2025-01-13T12:10:34Z",
              "updatedAt": "2025-01-13T12:29:22Z"
            },
            {
              "originalPosition": 952,
              "body": "I found this section quite hard to parse, and I don't think I've fully understood it. It started clicking when I arrived at line 1486. You try to define a general data format to accommodate for multiple types of proofs.\r\n\r\nWould it maybe help to first list the use cases (i.e., what is included) and then generalize that into one data structure? The use-cases don't explicitly refer to the fields in the `CombinedTreeProof` data structure anyways.",
              "createdAt": "2025-01-13T12:17:20Z",
              "updatedAt": "2025-01-13T12:29:22Z"
            },
            {
              "originalPosition": 1254,
              "body": "What does \"verify\" mean here? I think: check for equality of the hash, no? I think that's short enough s.t. it can be made explicit.",
              "createdAt": "2025-01-13T12:19:06Z",
              "updatedAt": "2025-01-13T12:29:22Z"
            },
            {
              "originalPosition": 1264,
              "body": "I think the draft must specify that clients must check that the timestamp the log shows them is sufficiently close to their submission. Otherwise, all that will ever be checked is monotonicity.",
              "createdAt": "2025-01-13T12:21:56Z",
              "updatedAt": "2025-01-13T12:29:22Z"
            },
            {
              "originalPosition": 1454,
              "body": "Again, maybe worth pointing out that \"verify\" means \"check for equality.\"",
              "createdAt": "2025-01-13T12:27:23Z",
              "updatedAt": "2025-01-13T12:29:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrnaA86ZEmr4",
          "commit": {
            "abbreviatedOid": "bc7098f"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-01-22T19:41:52Z",
          "updatedAt": "2025-01-22T19:41:53Z",
          "comments": [
            {
              "originalPosition": 251,
              "body": "I maybe need a better term. A \"full subtree\" is any one with 2^n leaves. And then we say we want the smallest set possible of full subtrees that cover the full tree (the largest full subtrees possible).",
              "createdAt": "2025-01-22T19:41:52Z",
              "updatedAt": "2025-01-22T19:41:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrnaA86ZQaVO",
          "commit": {
            "abbreviatedOid": "bc7098f"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-01-23T23:11:33Z",
          "updatedAt": "2025-01-23T23:11:33Z",
          "comments": [
            {
              "originalPosition": 425,
              "body": "The issue is that, in some cases, we need to provide a proof from the prefix tree in an expired node. Whether or not depends on whether we started at an expired root, or we started at an unexpired node and recursed to an expired one.",
              "createdAt": "2025-01-23T23:11:33Z",
              "updatedAt": "2025-01-23T23:11:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrnaA86ZQ_Ca",
          "commit": {
            "abbreviatedOid": "bc7098f"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-01-24T00:03:10Z",
          "updatedAt": "2025-01-24T00:03:10Z",
          "comments": [
            {
              "originalPosition": 568,
              "body": "The implicit tree does not have the property that every non-leaf has both a left and right child.",
              "createdAt": "2025-01-24T00:03:10Z",
              "updatedAt": "2025-01-24T00:03:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrnaA86ZUAIm",
          "commit": {
            "abbreviatedOid": "bc7098f"
          },
          "author": "felixlinker",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-01-24T09:38:08Z",
          "updatedAt": "2025-01-24T09:38:08Z",
          "comments": [
            {
              "originalPosition": 568,
              "body": "Ah, makes sense! Still think it'd be beneficial to make it explicit that the algorithm computes a list.",
              "createdAt": "2025-01-24T09:38:08Z",
              "updatedAt": "2025-01-24T09:38:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrnaA86ZmciM",
          "commit": {
            "abbreviatedOid": "bc7098f"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-01-28T03:02:53Z",
          "updatedAt": "2025-01-28T03:02:53Z",
          "comments": [
            {
              "originalPosition": 763,
              "body": "Sorry, what is the contradiction?",
              "createdAt": "2025-01-28T03:02:53Z",
              "updatedAt": "2025-01-28T03:02:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrnaA86Zmd42",
          "commit": {
            "abbreviatedOid": "bc7098f"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-01-28T03:11:20Z",
          "updatedAt": "2025-01-28T03:11:21Z",
          "comments": [
            {
              "originalPosition": 804,
              "body": "No, these are durations not timestamps",
              "createdAt": "2025-01-28T03:11:20Z",
              "updatedAt": "2025-01-28T03:11:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrnaA86ZmiPw",
          "commit": {
            "abbreviatedOid": "bc7098f"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-01-28T03:34:51Z",
          "updatedAt": "2025-01-28T03:34:51Z",
          "comments": [
            {
              "originalPosition": 1054,
              "body": "The timestamps will always be the same, but repeated PrefixProofs may (will) be for different indices. So different PrefixProofs are valuable, but repeated timestamps are wasted space",
              "createdAt": "2025-01-28T03:34:51Z",
              "updatedAt": "2025-01-28T03:35:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrnaA86Zml6k",
          "commit": {
            "abbreviatedOid": "bc7098f"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-01-28T03:57:58Z",
          "updatedAt": "2025-01-28T03:57:58Z",
          "comments": [
            {
              "originalPosition": 1254,
              "body": "Will specify this more clearly in a follow-up PR",
              "createdAt": "2025-01-28T03:57:58Z",
              "updatedAt": "2025-01-28T03:57:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrnaA86ZmmSH",
          "commit": {
            "abbreviatedOid": "bc7098f"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-01-28T04:00:15Z",
          "updatedAt": "2025-01-28T04:00:15Z",
          "comments": [
            {
              "originalPosition": 1264,
              "body": "Verifying that the rightmost timestamp is sufficiently recent is part of verifying \"as if it were a SearchResponse for the most recent version of `label`\"",
              "createdAt": "2025-01-28T04:00:15Z",
              "updatedAt": "2025-01-28T04:00:16Z"
            }
          ]
        }
      ]
    }
  ]
}