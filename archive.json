{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2025-06-22T01:12:51.442791+00:00",
  "repo": "ietf-wg-keytrans/draft-protocol",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "documentation",
      "description": "Improvements or additions to documentation",
      "color": "0075ca"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    }
  ],
  "issues": [
    {
      "number": 1,
      "id": "I_kwDOLrnaA86FSxiE",
      "title": "Provide a way to bulk-initialize a log",
      "url": "https://github.com/ietf-wg-keytrans/draft-protocol/issues/1",
      "state": "OPEN",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "There are two aspects to this:\r\n\r\n1. We want to be able to add a certain number of fake entries to hide the actual size of the log.\r\n2. We want to be able to add pre-existing key-value pairs without having one log entry per pair (like we would for key-value pairs added after log creation).\r\n\r\nIt should be very efficient to have a large number of fake prefix tree entries. We also want to not leak the number of real entries that a log starts with",
      "createdAt": "2024-04-10T19:33:46Z",
      "updatedAt": "2024-04-10T19:33:46Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 5,
      "id": "I_kwDOLrnaA86KWbPl",
      "title": "Prefix tree should commit to sets of versions",
      "url": "https://github.com/ietf-wg-keytrans/draft-protocol/issues/5",
      "state": "CLOSED",
      "author": "felixlinker",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Currently, the prefix tree commits to one key-version pair per leaf. I would argue that the leafs should commit to lists of key-version pairs (as the Merkle^2 paper suggests). This way, users can more easily monitor that the server did not include a fake key before to the current epoch.",
      "createdAt": "2024-05-28T13:52:53Z",
      "updatedAt": "2024-05-29T16:31:19Z",
      "closedAt": "2024-05-29T16:31:18Z",
      "comments": [
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm not sure there's any security benefit to having multiple key-version pairs per leaf. It makes things more complicated though, because you have to add an extra step where you are digging into the multiple changes that happened at that one leaf",
          "createdAt": "2024-05-28T16:51:25Z",
          "updatedAt": "2024-05-28T16:51:25Z"
        },
        {
          "author": "felixlinker",
          "authorAssociation": "COLLABORATOR",
          "body": "Brendan and I clarified this issue in a call. My understanding of which indices are used in the prefix tree was wrong.",
          "createdAt": "2024-05-29T16:31:18Z",
          "updatedAt": "2024-05-29T16:31:18Z"
        }
      ]
    },
    {
      "number": 15,
      "id": "I_kwDOLrnaA86r6whh",
      "title": "SearchRequest.last only implicitly defined",
      "url": "https://github.com/ietf-wg-keytrans/draft-protocol/issues/15",
      "state": "OPEN",
      "author": "felixlinker",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The field [`SearchRequest.last`](https://github.com/ietf-wg-keytrans/draft-protocol/blob/main/draft-ietf-keytrans-protocol.md?plain=1#L1440) is only implicitly defined. This should be made explicit.",
      "createdAt": "2025-02-27T11:59:53Z",
      "updatedAt": "2025-02-27T11:59:53Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 16,
      "id": "I_kwDOLrnaA86r6_AU",
      "title": "Section 11.1 (Search) is inconsistent",
      "url": "https://github.com/ietf-wg-keytrans/draft-protocol/issues/16",
      "state": "CLOSED",
      "author": "felixlinker",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I'm having issues implementing [Section 11.1 (Search)](https://ietf-wg-keytrans.github.io/draft-protocol/draft-ietf-keytrans-protocol.html#section-11.1). My problems are the following two statements.\n\n> The `search` field contains the output of updating the user's view of the tree [...].\n\n> The `inclusion` field contains a proof of inclusion for all of the log tree leaves where either a search proof was provided in `CombinedTreeProof.prefix_proofs` [...].\n\nHere are my issues.\n1. `CombinedTreeProof` is a type, but its used as a field. It is unclear which field `CombinedTreeProof.prefix_proofs` refers to. I presume, it refers to `search.prefix_proofs` (if I'm correct, this should be fixed).\n2. As per [10.3.1](https://ietf-wg-keytrans.github.io/draft-protocol/draft-ietf-keytrans-protocol.html#name-updating-view), `search` only provides timestamps. Thus, `search.prefix_proofs` should be empty, so the specification of `inclusion` does not make sense.",
      "createdAt": "2025-02-27T12:22:49Z",
      "updatedAt": "2025-02-28T13:29:56Z",
      "closedAt": "2025-02-28T13:29:56Z",
      "comments": [
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "For issue 1: Yes, `search.prefix_proofs` is what was meant\n\nFor issue 2: \"The search field contains the output of updating the user's view of the tree to match FullTreeHead.tree_head.size **followed by either a fixed-version or greatest-version search for the requested label**\"\n\nThe fixed-version or greatest-version search step is where `prefix_proofs` might have some data populated in it",
          "createdAt": "2025-02-27T17:34:29Z",
          "updatedAt": "2025-02-27T17:34:29Z"
        }
      ]
    },
    {
      "number": 18,
      "id": "I_kwDOLrnaA86sE6p6",
      "title": "VRF.Np undefined",
      "url": "https://github.com/ietf-wg-keytrans/draft-protocol/issues/18",
      "state": "OPEN",
      "author": "felixlinker",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "[`VRF.Np`](https://github.com/ietf-wg-keytrans/draft-protocol/blob/main/draft-ietf-keytrans-protocol.md?plain=1#L1451) is referenced in the definition of `BinaryLadderStep`, but undefined. I presume it is the byte-length of a VRF proof, but this is not mentioned.",
      "createdAt": "2025-02-28T12:00:35Z",
      "updatedAt": "2025-02-28T12:00:35Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 20,
      "id": "I_kwDOLrnaA86sFoRS",
      "title": "Greatest-Version Search - Unclear Specification",
      "url": "https://github.com/ietf-wg-keytrans/draft-protocol/issues/20",
      "state": "OPEN",
      "author": "felixlinker",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "https://github.com/ietf-wg-keytrans/draft-protocol/blob/9bf448a1508983ae4e3ce13067044928da5c46a8/draft-ietf-keytrans-protocol.md?plain=1#L896\n\nTargeting the greatest version globally or the greatest version in that log entry?",
      "createdAt": "2025-02-28T13:28:26Z",
      "updatedAt": "2025-03-04T18:30:03Z",
      "closedAt": null,
      "comments": [
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "Greatest version globally",
          "createdAt": "2025-02-28T23:48:28Z",
          "updatedAt": "2025-02-28T23:48:28Z"
        },
        {
          "author": "felixlinker",
          "authorAssociation": "COLLABORATOR",
          "body": "Okay, thanks! Follow-up question. What does it mean to \"target the label's greatest version\"?\n\nThe [binary ladder section](https://ietf-wg-keytrans.github.io/draft-protocol/draft-ietf-keytrans-protocol.html#name-binary-ladder) specifies two types of binary ladders. One to prove the highest version, one to prove one specific versions.\n\nSpecifically, I'm wondering about the following scenario. A client requests a label's highest version. The log provides them with a series of binary ladders as specified in [Sec. 7](https://ietf-wg-keytrans.github.io/draft-protocol/draft-ietf-keytrans-protocol.html#name-greatest-version-searches). The first binary ladder is for a log entry where the highest version is not yet present. Will the proof be formatted like a highest version proof or a specific version proof? This is not specified. I guess it will be a proof of non-inclusion for a specific version.",
          "createdAt": "2025-03-03T12:14:47Z",
          "updatedAt": "2025-03-03T12:14:47Z"
        },
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "There's only one type of binary ladder described. \"Targeting version 6\" means that it's the binary ladder you'd get if 6 was the greatest version that existed: 0, 1, 3, 7, 5, 6\n\nSo for a greatest version search, every binary ladder (= series of lookups in a prefix tree) will lookup the same versions in the same order, but terminate in different places as the search progresses",
          "createdAt": "2025-03-04T18:23:55Z",
          "updatedAt": "2025-03-04T18:23:55Z"
        },
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "Reading that section again after a while away, I agree it's confusing and can work on some text",
          "createdAt": "2025-03-04T18:24:23Z",
          "updatedAt": "2025-03-04T18:24:23Z"
        },
        {
          "author": "felixlinker",
          "authorAssociation": "COLLABORATOR",
          "body": "Okay! I also have some uncommitted changes locally. I will open a PR and we can discuss.\n\nBut I still don't understand how a binary ladder would be formatted if a log entry along the frontier didn't include that version yet - that could be, right?\n\nLet's say, the first log entry that is touched by the search only includes key versions up to 2. How would the binary ladder be constructed? The most efficient one would be 0, 1, 3. But the specification is not explicit here.",
          "createdAt": "2025-03-04T18:27:33Z",
          "updatedAt": "2025-03-04T18:27:33Z"
        },
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "If the version we're searching for is 6, then the binary ladder steps will always be: 0, 1, 3, 7, 5, 6. If the highest version in some log entry is 2, then you will do: proof of inclusion for 0 and 1, terminated by proof of non-inclusion for 3.",
          "createdAt": "2025-03-04T18:30:02Z",
          "updatedAt": "2025-03-04T18:30:02Z"
        }
      ]
    },
    {
      "number": 22,
      "id": "I_kwDOLrnaA86se5iB",
      "title": "Binary Ladder for Fixed Version Search Optimization",
      "url": "https://github.com/ietf-wg-keytrans/draft-protocol/issues/22",
      "state": "OPEN",
      "author": "felixlinker",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Two questions on the binary ladder for fixed version searches as described [here](https://ietf-wg-keytrans.github.io/draft-protocol/draft-ietf-keytrans-protocol.html#section-5.1-4).\n\n1. Presume highest version is 7 and 6 is queried. It is stated: \"the series of lookups ends after the first proof of inclusion for a\nversion greater than or equal to the target version.\" Does this mean 6 is not proven to be included in the prefix tree? It sounds like that, but it seems odd.\n2. It is stated that proofs of inclusion can be omitted should they have been provided for log tree entries younger than the one at hand. Why is this optimization not possible for proofs of a highest version?",
      "createdAt": "2025-03-04T10:40:50Z",
      "updatedAt": "2025-04-08T11:52:58Z",
      "closedAt": null,
      "comments": [
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "> Presume highest version is 7 and 6 is queried. It is stated: \"the series of lookups ends after the first proof of inclusion for a\nversion greater than or equal to the target version.\" Does this mean 6 is not proven to be included in the prefix tree? It sounds like that, but it seems odd.\n\nThat /can/ happen. Your binary ladder will be for version 6 will be versions: 0, 1, 3, 7, 5, 6. You can do an entire binary search through the log entries for version 6 but always terminate the binary ladder early with a proof of inclusion for version 7. The implication there though is that version 6 and 7 were created in the same epoch.\n\n> It is stated that proofs of inclusion can be omitted should they have been provided for log tree entries younger than the one at hand. Why is this optimization not possible for proofs of a highest version?\n\nI'm not sure what you mean here.",
          "createdAt": "2025-03-04T21:01:46Z",
          "updatedAt": "2025-03-04T21:01:46Z"
        },
        {
          "author": "felixlinker",
          "authorAssociation": "COLLABORATOR",
          "body": "Okay, your edits made it clearer. I read it as: \"There are two flavors of a binary ladder and we can optimize one of them in two ways.\" I was wondering why the second optimization couldn't apply to the greatest-version search. But now I see that the optimizations apply generally.",
          "createdAt": "2025-03-11T12:21:22Z",
          "updatedAt": "2025-03-11T12:21:22Z"
        },
        {
          "author": "felixlinker",
          "authorAssociation": "COLLABORATOR",
          "body": "For future reference: I think this issue was addressed by #31 but I have to double-check.",
          "createdAt": "2025-04-08T11:52:56Z",
          "updatedAt": "2025-04-08T11:52:56Z"
        }
      ]
    },
    {
      "number": 24,
      "id": "I_kwDOLrnaA86trCE9",
      "title": "How does a server negatively respond to a search request?",
      "url": "https://github.com/ietf-wg-keytrans/draft-protocol/issues/24",
      "state": "OPEN",
      "author": "felixlinker",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Presume a client queries a server for a non-existent label's latest version or a non-existent version of a label. How does the server respond such queries? This doesn't seem to be specified. The `SearchResponse` struct fields don't look like they could encode a negative response, and the corresponding section also doesn't mention it. (See https://ietf-wg-keytrans.github.io/draft-protocol/draft-ietf-keytrans-protocol.html#name-search)",
      "createdAt": "2025-03-12T12:03:27Z",
      "updatedAt": "2025-03-12T12:03:27Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 25,
      "id": "I_kwDOLrnaA86trSOa",
      "title": "Clients do not verify which log entries are distinguished",
      "url": "https://github.com/ietf-wg-keytrans/draft-protocol/issues/25",
      "state": "OPEN",
      "author": "felixlinker",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "For greatest-version searches, the spec requires clients to branch on whether the proofs of inclusion on prefix trees start the the implicit binary search tree's root or at a distinguished log entry. Clients can implicitly tell whether the provided log entry is distinguished by checking whether it's the root or not, but the specification does not tell clients to verify that a provided non-root is a distinguished log entry, and I think, they cannot. When updating the view on the log tree, clients are only given nodes on the frontier, and nodes on the path from their previous root back to the frontier. It seems to me that this would not be sufficient to verify which nodes on the frontier are distinguished.",
      "createdAt": "2025-03-12T12:28:17Z",
      "updatedAt": "2025-03-12T19:56:21Z",
      "closedAt": null,
      "comments": [
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "The timestamps of the nodes on the frontier are all that are necessary to find the rightmost distinguished log entry",
          "createdAt": "2025-03-12T19:56:20Z",
          "updatedAt": "2025-03-12T19:56:20Z"
        }
      ]
    },
    {
      "number": 27,
      "id": "I_kwDOLrnaA86tru29",
      "title": "node.type used but not defined",
      "url": "https://github.com/ietf-wg-keytrans/draft-protocol/issues/27",
      "state": "OPEN",
      "author": "felixlinker",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The hash computation in 9.5/9.6 uses the field `node.type` but it is not specified anywhere. I can see what it ought to mean, however, there are some ambiguities. For example, Figure 5 shows a prefix tree with nodes that have only a single child node. I guess it is expected that in an implementation, every node in the prefix tree has either two children or is a leaf. The node that is not rendered is probably of type `emptyNode`. But this should be made explicit.",
      "createdAt": "2025-03-12T13:09:25Z",
      "updatedAt": "2025-03-12T13:09:39Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 28,
      "id": "I_kwDOLrnaA86tr1qC",
      "title": "node.value for leafs undefined",
      "url": "https://github.com/ietf-wg-keytrans/draft-protocol/issues/28",
      "state": "OPEN",
      "author": "felixlinker",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Both sections 9.5/9.6 define the hashes of nodes, and there are base cases for leaves. Leaves are defined as `0x0_ || node.value`, but `node.value` is not defined. It is implicitly clear from context that this should be `LogLeaf` and `PrefixLeaf`, but it should be made explicit.",
      "createdAt": "2025-03-12T13:19:41Z",
      "updatedAt": "2025-03-12T13:19:41Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 29,
      "id": "I_kwDOLrnaA86tsPxh",
      "title": "RFC 8446 does not define optional fields but this spec uses them",
      "url": "https://github.com/ietf-wg-keytrans/draft-protocol/issues/29",
      "state": "OPEN",
      "author": "felixlinker",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "It should be made explicit how to encode fields that are optional. Are they left out? Are they replaced with a zero-bytes sequence or something similar?\n\nI would also like to use syntax that checks whether an optional field is present. Should we use `undefined` as the value of optional fields that have no \"actual value\"?",
      "createdAt": "2025-03-12T13:51:03Z",
      "updatedAt": "2025-03-14T07:16:19Z",
      "closedAt": null,
      "comments": [
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "The proper definition is in MLS: https://www.rfc-editor.org/rfc/rfc9420.html#name-optional-value\n\nThat said, we are changing the encoding language soon so this is fine to ignore",
          "createdAt": "2025-03-14T07:16:18Z",
          "updatedAt": "2025-03-14T07:16:18Z"
        }
      ]
    },
    {
      "number": 33,
      "id": "I_kwDOLrnaA86yYn1F",
      "title": "Updating view: Client cannot verify all provided timestamps",
      "url": "https://github.com/ietf-wg-keytrans/draft-protocol/issues/33",
      "state": "OPEN",
      "author": "felixlinker",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "A couple of observations first:\n- [4.2](https://ietf-wg-keytrans.github.io/draft-protocol/draft-ietf-keytrans-protocol.html#name-algorithm) and [11.3.1](https://ietf-wg-keytrans.github.io/draft-protocol/draft-ietf-keytrans-protocol.html#section-11.3.1) only specify timepoints and a proof of consistency to be sent to a client to update their view of the tree.\n- [11.3.4](https://ietf-wg-keytrans.github.io/draft-protocol/draft-ietf-keytrans-protocol.html#name-greatest-version-search) specifies that prefix proofs are provided for all children of the oldest distinguished log entry (or root) in the implicit binary search tree are provided, and [12.1](https://ietf-wg-keytrans.github.io/draft-protocol/draft-ietf-keytrans-protocol.html#name-search) specifies that inclusion proofs are provided for all prefix proofs.\n\nThus, it seems to me that the server could lie about the timepoints of all distinguished log entries that lie on the path between the old implicit binary search tree's root and the new, oldest distinguished log entry (exclusive for both nodes).\n\nIt doesn't seem to me that this is a problem because the server should not be able to convince clients that different log entries are distinguished. The algorithm in [7.2](https://ietf-wg-keytrans.github.io/draft-protocol/draft-ietf-keytrans-protocol.html#section-7.2) should be robust enough as the server must prove inclusion of the oldest distinguished log entry to clients.\n\nHowever, if the server can lie: Why even include these timestamps? ",
      "createdAt": "2025-04-14T11:39:51Z",
      "updatedAt": "2025-04-14T11:41:26Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 34,
      "id": "I_kwDOLrnaA86yYtai",
      "title": "Proofs of consistency underspecified",
      "url": "https://github.com/ietf-wg-keytrans/draft-protocol/issues/34",
      "state": "OPEN",
      "author": "felixlinker",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I suspect that consistency proofs should be constructed just as in https://www.rfc-editor.org/rfc/rfc6962#section-2.1.2, however, this is not explicit.",
      "createdAt": "2025-04-14T11:48:36Z",
      "updatedAt": "2025-04-14T11:48:36Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 36,
      "id": "I_kwDOLrnaA86yoeNb",
      "title": "Unclear what exactly is contained in SearchResponse.binary_ladder",
      "url": "https://github.com/ietf-wg-keytrans/draft-protocol/issues/36",
      "state": "CLOSED",
      "author": "felixlinker",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "In [12.1](https://ietf-wg-keytrans.github.io/draft-protocol/draft-ietf-keytrans-protocol.html#section-12.1), it is written:\n\n> The `binary_ladder` field contains these structures in the same order that the versions are output by the algorithm in [Section 5](https://ietf-wg-keytrans.github.io/draft-protocol/draft-ietf-keytrans-protocol.html#binary-ladder).\n\nThis suggests that also information regarding prefix tree leaves for proof of non-inclusion are stored in this field, but I don't think this is the case. I think that because (a) non-inclusion leaf information change per leaf, and (b) it is provided as part of a `PrefixSearchResult`.\n\nThus, I guess that `binary_ladder` only contains information for labels which are proven to be included in the binary ladder, right? That should be clarified.",
      "createdAt": "2025-04-15T16:12:17Z",
      "updatedAt": "2025-04-15T16:27:11Z",
      "closedAt": "2025-04-15T16:27:10Z",
      "comments": [
        {
          "author": "felixlinker",
          "authorAssociation": "COLLABORATOR",
          "body": "Nvm. I was being stupid.",
          "createdAt": "2025-04-15T16:27:10Z",
          "updatedAt": "2025-04-15T16:27:10Z"
        }
      ]
    },
    {
      "number": 37,
      "id": "I_kwDOLrnaA86y7eqP",
      "title": "Is PrefixSearchResult.depth zero- or one-based?",
      "url": "https://github.com/ietf-wg-keytrans/draft-protocol/issues/37",
      "state": "CLOSED",
      "author": "felixlinker",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Title says it all. Is a tree's root at depth zero or at depth one?",
      "createdAt": "2025-04-17T09:23:59Z",
      "updatedAt": "2025-04-24T22:07:06Z",
      "closedAt": "2025-04-24T22:07:06Z",
      "comments": []
    },
    {
      "number": 38,
      "id": "I_kwDOLrnaA86y7rMM",
      "title": "Define distinguished log entries on frontier only",
      "url": "https://github.com/ietf-wg-keytrans/draft-protocol/issues/38",
      "state": "CLOSED",
      "author": "felixlinker",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "It seems to me that distinguished log entries are only relevant when they occur on a log's frontier. Is that correct?\n\nIf it is, it could simplify the algorithm and definition to only compute distinguished log entries on the frontier.",
      "createdAt": "2025-04-17T09:44:41Z",
      "updatedAt": "2025-04-17T19:20:15Z",
      "closedAt": "2025-04-17T19:20:15Z",
      "comments": [
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "No, all distinguished log entries matter because label owners have to check that all distinguished log entries correctly represent the label's greatest version. If a label owner is offline for a long period of time, when they come back they basically have to do a depth-first search to find all the distinguished log entries they missed.",
          "createdAt": "2025-04-17T18:19:52Z",
          "updatedAt": "2025-04-17T18:19:52Z"
        }
      ]
    }
  ],
  "pulls": [
    {
      "number": 2,
      "id": "PR_kwDOLrnaA85wxAUx",
      "title": "Improvements to hash computation definitions",
      "url": "https://github.com/ietf-wg-keytrans/draft-protocol/pull/2",
      "state": "CLOSED",
      "author": "felixlinker",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Hi Brendan,\r\n\r\nTwo suggestions.\r\n\r\n1. I made the recursion on the hash computation more explicit and gave also leaves the value field. I think this is clearer. The only downside is that you might need to store more information on disk, but the data structures will likely not be implemented like this anyways, no?\r\n2. I dropped that cryptographic computations must be done with the TLS presentation language, because in the algorithms, you reference individual `opaque` fields only anyways. Will this change with the definition of other primitives? Could be. But so far, I thought that this sentence would only falsely lead people to believe that they must use TLS datastructures, ASN.1 parsers, etc., in the library whereas my understanding is that they need not do that.\r\n\r\nCheers!\r\n\r\nFelix",
      "createdAt": "2024-05-28T13:27:51Z",
      "updatedAt": "2024-05-29T16:31:59Z",
      "baseRepository": "ietf-wg-keytrans/draft-protocol",
      "baseRefName": "main",
      "baseRefOid": "9002fc9b5634469fb3cdc4a474532e139ff150d5",
      "headRepository": "felixlinker/draft-keytrans",
      "headRefName": "hashing",
      "headRefOid": "65aba48f82c26aa71a213684475746fe999bf67c",
      "closedAt": "2024-05-29T16:31:58Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "felixlinker",
          "authorAssociation": "COLLABORATOR",
          "body": "Brendan and I discussed this PR in a call. I missed that the TLS data-structures to which I added the `value` field are used elsewhere in cryptographic computations.",
          "createdAt": "2024-05-29T16:31:58Z",
          "updatedAt": "2024-05-29T16:31:58Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOLrnaA858LrU7",
          "commit": {
            "abbreviatedOid": "d2e8b1f"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-28T17:06:39Z",
          "updatedAt": "2024-05-28T17:18:03Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Crypto computations do indeed need to be done in TLS format. TLS specifies endianness, that `opaque` fields are length-prefixed byte strings, etc. Not related to ASN.1. See: https://datatracker.ietf.org/doc/html/rfc5246#section-4",
              "createdAt": "2024-05-28T17:06:40Z",
              "updatedAt": "2024-05-28T17:18:03Z"
            },
            {
              "originalPosition": 16,
              "body": "I don't think it makes sense to store the `value` in the leaf node, as the value can be immediately computed from `key_version`. So it is redundant when this struct is used later on.",
              "createdAt": "2024-05-28T17:13:44Z",
              "updatedAt": "2024-05-28T17:18:03Z"
            },
            {
              "originalPosition": 33,
              "body": "The reason to explicitly say `parent.value = ` is that `value` is an actual field of `PrefixParent` that needs to be populated, potentially stored on-disk. That connection is kind of lost when you roll it into `nodeValue`. And unlike `PrefixLeaf`, `value` can't be computed in isolation",
              "createdAt": "2024-05-28T17:16:11Z",
              "updatedAt": "2024-05-28T17:18:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrnaA858TBHj",
          "commit": {
            "abbreviatedOid": "d2e8b1f"
          },
          "author": "felixlinker",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-29T13:07:33Z",
          "updatedAt": "2024-05-29T13:07:33Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "Is this the level that this spec will operate on? What is stored on disk and what not? This seems like implementation-level details we should not address. Rather, we should address the logic behind the system and have the pseudocode be as understandable as possible. So if leafs have a concept of *value* associated with them, I find it clearer to be explicit about that. Implementors can then apply all nifty tricks to get the size on disk down as much as possible.",
              "createdAt": "2024-05-29T13:07:33Z",
              "updatedAt": "2024-05-29T13:07:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrnaA858TBIw",
          "commit": {
            "abbreviatedOid": "d2e8b1f"
          },
          "author": "felixlinker",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-29T13:07:35Z",
          "updatedAt": "2024-05-29T13:07:35Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "Same as above.",
              "createdAt": "2024-05-29T13:07:35Z",
              "updatedAt": "2024-05-29T13:07:35Z"
            }
          ]
        }
      ]
    },
    {
      "number": 3,
      "id": "PR_kwDOLrnaA85wxLKA",
      "title": "More intuition on tree construction",
      "url": "https://github.com/ietf-wg-keytrans/draft-protocol/pull/3",
      "state": "MERGED",
      "author": "felixlinker",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "With this PR, I try to give a more high-level intuition of what happens in KT, but there is a discrepancy between what I write here (and the Merkle^2 paper) and what you write. I will open an issue separately for that.",
      "createdAt": "2024-05-28T13:48:13Z",
      "updatedAt": "2024-06-02T22:31:48Z",
      "baseRepository": "ietf-wg-keytrans/draft-protocol",
      "baseRefName": "main",
      "baseRefOid": "9002fc9b5634469fb3cdc4a474532e139ff150d5",
      "headRepository": "felixlinker/draft-keytrans",
      "headRefName": "new-intro",
      "headRefOid": "f851f0aa3519c9e2b87fd359e5117531cb35b7b1",
      "closedAt": "2024-06-02T22:31:48Z",
      "mergedAt": "2024-06-02T22:31:48Z",
      "mergedBy": "Bren2010",
      "mergeCommit": {
        "oid": "48f57350664ab9417bd4b2ffb6046c4263b2b9cc"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOLrnaA858Liad",
          "commit": {
            "abbreviatedOid": "4617696"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-28T16:48:04Z",
          "updatedAt": "2024-05-28T16:48:04Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "Maintains two things:\r\n- A log of changes to lookup keys\r\n- A set of key-version pairs",
              "createdAt": "2024-05-28T16:48:04Z",
              "updatedAt": "2024-05-28T16:48:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrnaA858gb9G",
          "commit": {
            "abbreviatedOid": "f88f1db"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-30T17:03:48Z",
          "updatedAt": "2024-05-30T18:05:39Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "```suggestion\r\nservice. To do so, KT maintains two structures: (i) a log of each change to any\r\nkey's value, and (ii) a set containing all of the key-version pairs that have been\r\nlogged. When clients query a KT service, they\r\n```\r\nNo maps. A log and a set",
              "createdAt": "2024-05-30T17:03:49Z",
              "updatedAt": "2024-05-30T18:05:39Z"
            },
            {
              "originalPosition": 20,
              "body": "```suggestion\r\nto both these structures with a *root hash*.\r\n```",
              "createdAt": "2024-05-30T17:06:54Z",
              "updatedAt": "2024-05-30T18:05:39Z"
            },
            {
              "originalPosition": 23,
              "body": "```suggestion\r\nTwo clients which have the same root hash are guaranteed to have the same view\r\nof the tree, and thus would always receive the same result for the same query.\r\n```",
              "createdAt": "2024-05-30T17:07:59Z",
              "updatedAt": "2024-05-30T18:05:39Z"
            },
            {
              "originalPosition": 27,
              "body": "```suggestion\r\nprefix trees. The log tree commits to (i) and \r\nthe prefix tree commits to (ii). This section describes the operation of\r\n```",
              "createdAt": "2024-05-30T17:09:24Z",
              "updatedAt": "2024-05-30T18:05:39Z"
            },
            {
              "originalPosition": 34,
              "body": "```suggestion\r\nBoth types of trees consist of\r\n*nodes* which have a byte string as their *hash value*. A node is either a\r\n*leaf* if it has no children, or a *parent*\r\n```",
              "createdAt": "2024-05-30T17:22:04Z",
              "updatedAt": "2024-05-30T18:05:39Z"
            },
            {
              "originalPosition": 49,
              "body": "```suggestion\r\nwas added and are constructed as *left-balanced* binary trees.\r\n```\r\nSaying what the values of the leaves are is getting ahead of yourself. Don't need to discuss leaf values until we get to Combined Tree",
              "createdAt": "2024-05-30T17:51:54Z",
              "updatedAt": "2024-05-30T18:05:39Z"
            },
            {
              "originalPosition": 60,
              "body": "```suggestion\r\nLog trees initially consist of a single leaf node. New leaves are\r\n```",
              "createdAt": "2024-05-30T17:52:51Z",
              "updatedAt": "2024-05-30T18:05:40Z"
            },
            {
              "originalPosition": 70,
              "body": "```suggestion\r\nWhile leaves contain arbitrary data, the value of a parent node is always the\r\nhash of the combined values of its left and right children.\r\n```\r\nImo the previous text is clearer",
              "createdAt": "2024-05-30T17:54:29Z",
              "updatedAt": "2024-05-30T18:05:40Z"
            },
            {
              "originalPosition": 87,
              "body": "When doing little changes, it keeps the diff cleaner to not rewrap text. Don't need to undo wraps in this PR, just saying for future",
              "createdAt": "2024-05-30T17:55:12Z",
              "updatedAt": "2024-05-30T18:05:40Z"
            },
            {
              "originalPosition": 177,
              "body": "```suggestion\r\nmaintains the set of index-version pairs. Importantly, the root hash value of the\r\nprefix tree after adding a new index-version pair is stored in a leaf of the log\r\n```\r\nNeed to use index consistently, not pseudonym",
              "createdAt": "2024-05-30T18:02:15Z",
              "updatedAt": "2024-05-30T18:05:40Z"
            },
            {
              "originalPosition": 123,
              "body": "```suggestion\r\nleft child if the first bit of a value is 0, or the right child if the first\r\n```\r\n\"Prefix tree is used for storing a set of values\" so sticking with value",
              "createdAt": "2024-05-30T18:03:50Z",
              "updatedAt": "2024-05-30T18:05:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrnaA858m21G",
          "commit": {
            "abbreviatedOid": "f88f1db"
          },
          "author": "felixlinker",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-31T11:03:36Z",
          "updatedAt": "2024-05-31T11:03:36Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "I think it's important to point out how the leafs of each tree are addressed. For (i), it's by a global version counter (actually, we should find a name for this; is there one?). For (ii), it's the output of the VRF for pseudonym + local version counter. I find this very important! A set cannot be indexed, yet we will index the trees.",
              "createdAt": "2024-05-31T11:03:36Z",
              "updatedAt": "2024-05-31T11:03:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrnaA858m5NN",
          "commit": {
            "abbreviatedOid": "f88f1db"
          },
          "author": "felixlinker",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-31T11:06:27Z",
          "updatedAt": "2024-05-31T11:06:27Z",
          "comments": [
            {
              "originalPosition": 49,
              "body": "I think it's important to provide intuitions as early as possible. Here one could say that an intuition was already provided in the introduction of the combined tree structure earlier, but readers who skip between sections might miss this.",
              "createdAt": "2024-05-31T11:06:27Z",
              "updatedAt": "2024-05-31T11:06:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrnaA858m5qe",
          "commit": {
            "abbreviatedOid": "f88f1db"
          },
          "author": "felixlinker",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-31T11:07:41Z",
          "updatedAt": "2024-05-31T11:07:41Z",
          "comments": [
            {
              "originalPosition": 70,
              "body": "Some complications arise from refactoring \"value\" into \"hash value\" and this is one of them. It was clearer before, but if we want to distinguish \"hash value\" from \"value\" (which I think we should), I'd rather be explicit here.",
              "createdAt": "2024-05-31T11:07:41Z",
              "updatedAt": "2024-05-31T11:07:41Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrnaA858m6Gz",
          "commit": {
            "abbreviatedOid": "f88f1db"
          },
          "author": "felixlinker",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-31T11:08:55Z",
          "updatedAt": "2024-05-31T11:08:55Z",
          "comments": [
            {
              "originalPosition": 87,
              "body": "Do you have any preference regarding how we handle formatting? When would you like to enforce the 80 characters limit?",
              "createdAt": "2024-05-31T11:08:55Z",
              "updatedAt": "2024-05-31T11:08:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrnaA858p9Ov",
          "commit": {
            "abbreviatedOid": "f88f1db"
          },
          "author": "felixlinker",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-31T17:28:28Z",
          "updatedAt": "2024-05-31T17:28:28Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "Okay, one could make the case that the indexing of the log is implicit. The position of the leaf determines its index. But since we will use the index-terminology anyways, I think it's clearer to say that both types of trees commit to an index-value store and are optimized for different kinds of proofs.",
              "createdAt": "2024-05-31T17:28:28Z",
              "updatedAt": "2024-05-31T17:28:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrnaA858unmG",
          "commit": {
            "abbreviatedOid": "286578b"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-06-02T19:29:54Z",
          "updatedAt": "2024-06-02T22:30:48Z",
          "comments": [
            {
              "originalPosition": 70,
              "body": "We should distinguish hash value from value. But in this text, we're talking about value. Talking about hash value adds an extra layer to understand",
              "createdAt": "2024-06-02T19:29:54Z",
              "updatedAt": "2024-06-02T22:30:48Z"
            },
            {
              "originalPosition": 87,
              "body": "When writing new text, 80 chars is good. When modifying existing text, the goal is to have a clear diff, so it's fine if lines end up uneven lengths",
              "createdAt": "2024-06-02T19:32:39Z",
              "updatedAt": "2024-06-02T22:30:48Z"
            },
            {
              "originalPosition": 95,
              "body": "```suggestion\r\nto efficiently produce proofs of membership and non-membership in the set.\r\n\r\nEach leaf node in a prefix tree represents a specific value, while each parent\r\nnode represents some prefix which all values in the subtree headed by that node\r\nhave in common. The subtree headed by a parent's left child contains all values\r\nthat share its prefix followed by an additional 0 bit, while the subtree headed\r\nby a parent's right child contains all values that share its prefix followed by\r\nan additional 1 bit.\r\n\r\nThe root node, in particular, represents the empty string as a prefix. The\r\nroot's left child contains all values that begin with a 0 bit, while the right\r\nchild contains all values that begin with a 1 bit.\r\n```",
              "createdAt": "2024-06-02T22:27:12Z",
              "updatedAt": "2024-06-02T22:30:48Z"
            },
            {
              "originalPosition": 122,
              "body": "```suggestion\r\nNew values are added to the tree by searching it according to the same process.\r\nIf the search terminates at a parent without a left or right child, a new leaf\r\nis simply added as the parent's missing child. If the search terminates at a\r\nleaf for the wrong value, one or more intermediate nodes are added until the new\r\nleaf and the existing leaf would no longer reside in the same place. That is,\r\nuntil we reach the first bit that differs between the new value and the existing\r\nvalue.\r\n```",
              "createdAt": "2024-06-02T22:28:33Z",
              "updatedAt": "2024-06-02T22:30:48Z"
            },
            {
              "originalPosition": 105,
              "body": "```suggestion\r\nleft child if the first bit of a value is 0, or the right child if the first bit\r\nis 1. This is then repeated for the second bit, third bit, and so on until the\r\nsearch either terminates at a leaf node (which may or may not be for the desired\r\nvalue), or a parent node that lacks the desired child.\r\n```",
              "createdAt": "2024-06-02T22:28:51Z",
              "updatedAt": "2024-06-02T22:30:48Z"
            },
            {
              "originalPosition": 131,
              "body": "```suggestion\r\nThe value of a leaf node is the encoded set member, while the value of a\r\nparent node is the hash of the combined values of its left and right children\r\n(or a stand-in value when one of the children doesn't exist).\r\n```",
              "createdAt": "2024-06-02T22:30:21Z",
              "updatedAt": "2024-06-02T22:30:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrnaA858usld",
          "commit": {
            "abbreviatedOid": "f851f0a"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-06-02T22:31:38Z",
          "updatedAt": "2024-06-02T22:31:38Z",
          "comments": []
        }
      ]
    },
    {
      "number": 4,
      "id": "PR_kwDOLrnaA85wxL1V",
      "title": "Add Felix Linker as author",
      "url": "https://github.com/ietf-wg-keytrans/draft-protocol/pull/4",
      "state": "MERGED",
      "author": "felixlinker",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-05-28T13:49:24Z",
      "updatedAt": "2024-05-28T16:43:37Z",
      "baseRepository": "ietf-wg-keytrans/draft-protocol",
      "baseRefName": "main",
      "baseRefOid": "9002fc9b5634469fb3cdc4a474532e139ff150d5",
      "headRepository": "felixlinker/draft-keytrans",
      "headRefName": "authorship",
      "headRefOid": "8ad7441a4043593e8bec351c3c8762d5ec4634c5",
      "closedAt": "2024-05-28T16:43:37Z",
      "mergedAt": "2024-05-28T16:43:37Z",
      "mergedBy": "Bren2010",
      "mergeCommit": {
        "oid": "610128224a781e017d916a5ed19b4b5be57ac5a3"
      },
      "comments": [
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "Feel free to add an organization as well if you'd like",
          "createdAt": "2024-05-28T16:43:32Z",
          "updatedAt": "2024-05-28T16:43:32Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 6,
      "id": "PR_kwDOLrnaA85xhltE",
      "title": "Figures",
      "url": "https://github.com/ietf-wg-keytrans/draft-protocol/pull/6",
      "state": "MERGED",
      "author": "felixlinker",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-06-05T09:21:57Z",
      "updatedAt": "2024-06-06T03:46:29Z",
      "baseRepository": "ietf-wg-keytrans/draft-protocol",
      "baseRefName": "main",
      "baseRefOid": "48f57350664ab9417bd4b2ffb6046c4263b2b9cc",
      "headRepository": "felixlinker/draft-keytrans",
      "headRefName": "diagrams",
      "headRefOid": "729b821e90cabf8340da1916266e47b79e6e53e1",
      "closedAt": "2024-06-06T03:46:29Z",
      "mergedAt": "2024-06-06T03:46:29Z",
      "mergedBy": "Bren2010",
      "mergeCommit": {
        "oid": "6e3f4698a915eca9f97575b524bb2e50e4f4b87a"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOLrnaA859Ns2r",
          "commit": {
            "abbreviatedOid": "729b821"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thank you!!",
          "createdAt": "2024-06-06T03:46:15Z",
          "updatedAt": "2024-06-06T03:46:15Z",
          "comments": []
        }
      ]
    },
    {
      "number": 7,
      "id": "PR_kwDOLrnaA85xkYLF",
      "title": "Editing",
      "url": "https://github.com/ietf-wg-keytrans/draft-protocol/pull/7",
      "state": "MERGED",
      "author": "felixlinker",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-06-05T14:59:28Z",
      "updatedAt": "2024-06-17T17:00:20Z",
      "baseRepository": "ietf-wg-keytrans/draft-protocol",
      "baseRefName": "main",
      "baseRefOid": "7ed4d53c2869595022acb9fe583fb30ecec427f9",
      "headRepository": "felixlinker/draft-keytrans",
      "headRefName": "editing",
      "headRefOid": "c3b8c7acbc34af133369a7a23d7192c8155618c6",
      "closedAt": "2024-06-17T17:00:20Z",
      "mergedAt": "2024-06-17T17:00:20Z",
      "mergedBy": "Bren2010",
      "mergeCommit": {
        "oid": "e7661dd33f5f327cc2a9afed6d2069904580b98e"
      },
      "comments": [
        {
          "author": "felixlinker",
          "authorAssociation": "COLLABORATOR",
          "body": "@Bren2010 I refactored \"pseudonym\" and \"search key\" into \"label\" and tried providing more intuition in the intro of the \"Searching the Tree\" section.\r\n\r\nI think we need both terms \"index\" and \"label\". For example, we counter for the leafs of the log tree also \"index\". This makes sense. I would say: \"index\" means the thing you _index_ a tree by, i.e., VRF-output or log-tree counter, and \"label\" means the thing you associate keys with, e.g., pseudonyms.\r\n\r\nCurrently, we don't define \"index\" but only use it implicitly. I don't think this is too bad right now, but could be improved.\r\n\r\nPR is ready for review and merge!",
          "createdAt": "2024-06-11T09:13:41Z",
          "updatedAt": "2024-06-11T09:13:41Z"
        },
        {
          "author": "felixlinker",
          "authorAssociation": "COLLABORATOR",
          "body": "@Bren2010 Addressed your comment on key updates and rebased onto main!",
          "createdAt": "2024-06-17T07:54:25Z",
          "updatedAt": "2024-06-17T07:54:25Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOLrnaA85-MCuN",
          "commit": {
            "abbreviatedOid": "0de4cb2"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Also does unfortunately need to be rebased",
          "createdAt": "2024-06-13T21:45:45Z",
          "updatedAt": "2024-06-14T04:35:02Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Here it seems you're using \"key\" as an abbreviation for \"public key\". Is that right? Public keys will not be the only things stored in a KT log. Labels may map to other labels, to arbitrary structured data, etc",
              "createdAt": "2024-06-13T21:45:45Z",
              "updatedAt": "2024-06-14T04:35:02Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrnaA85-fVNh",
          "commit": {
            "abbreviatedOid": "0de4cb2"
          },
          "author": "felixlinker",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-06-17T07:48:33Z",
          "updatedAt": "2024-06-17T07:48:33Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Correct. \"Key\" is supposed to mean \"public key.\" What you are saying is correct, but I think that my phrasing is accurate as I say that \"keys are associated with labels\" not \"labels map to keys.\"\r\n\r\nI clarified what \"key updates\" are now a bit bellow to avoid confusion! (See most recent commit.)",
              "createdAt": "2024-06-17T07:48:33Z",
              "updatedAt": "2024-06-17T07:48:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrnaA85-kN6K",
          "commit": {
            "abbreviatedOid": "c3b8c7a"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-06-17T17:00:14Z",
          "updatedAt": "2024-06-17T17:00:14Z",
          "comments": []
        }
      ]
    },
    {
      "number": 8,
      "id": "PR_kwDOLrnaA853Rzu0",
      "title": "Editing",
      "url": "https://github.com/ietf-wg-keytrans/draft-protocol/pull/8",
      "state": "MERGED",
      "author": "felixlinker",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I hope text is self-explanatory! :) Some of the changes are more straight-forward than others. If you want, we can split the PR up.",
      "createdAt": "2024-08-02T16:29:26Z",
      "updatedAt": "2024-08-22T07:35:23Z",
      "baseRepository": "ietf-wg-keytrans/draft-protocol",
      "baseRefName": "main",
      "baseRefOid": "e7661dd33f5f327cc2a9afed6d2069904580b98e",
      "headRepository": "ietf-wg-keytrans/draft-protocol",
      "headRefName": "editing",
      "headRefOid": "8d214c801ea825cc3bbf9d3822d0eaa05768dfc3",
      "closedAt": "2024-08-02T16:30:53Z",
      "mergedAt": "2024-08-02T16:30:53Z",
      "mergedBy": "felixlinker",
      "mergeCommit": {
        "oid": "8d214c801ea825cc3bbf9d3822d0eaa05768dfc3"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 9,
      "id": "PR_kwDOLrnaA855FzDL",
      "title": "Add aasvg dependency",
      "url": "https://github.com/ietf-wg-keytrans/draft-protocol/pull/9",
      "state": "MERGED",
      "author": "felixlinker",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Commit does the same as suggested here: https://github.com/ietf-wg-scitt/draft-ietf-scitt-architecture/pull/142\r\n\r\nWith the change, I can run `make` locally to preview changes, see warnings, etc.",
      "createdAt": "2024-08-22T08:13:52Z",
      "updatedAt": "2024-10-10T13:43:26Z",
      "baseRepository": "ietf-wg-keytrans/draft-protocol",
      "baseRefName": "main",
      "baseRefOid": "6daf33c8233a81fa57093289fb2a08a176a13ac6",
      "headRepository": "ietf-wg-keytrans/draft-protocol",
      "headRefName": "package-json",
      "headRefOid": "741acb77637651d7088bededd4288a5044875d80",
      "closedAt": "2024-09-13T04:07:23Z",
      "mergedAt": "2024-09-13T04:07:23Z",
      "mergedBy": "Bren2010",
      "mergeCommit": {
        "oid": "12f569da33954320c48045bfb5f629e54774a55e"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOLrnaA86GZrfs",
          "commit": {
            "abbreviatedOid": "741acb7"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-08-22T15:15:14Z",
          "updatedAt": "2024-08-22T15:15:14Z",
          "comments": []
        }
      ]
    },
    {
      "number": 10,
      "id": "PR_kwDOLrnaA85-PNV6",
      "title": "First step towards third-party auditing",
      "url": "https://github.com/ietf-wg-keytrans/draft-protocol/pull/10",
      "state": "MERGED",
      "author": "felixlinker",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I started writing about third-party auditing. The PR is not complete yet, but I wanted to iterate early on! Especially curious to hear what you think about the TLS encoding.\r\n\r\nWould be great to hear whether you think this goes in the right direction!",
      "createdAt": "2024-10-10T15:05:25Z",
      "updatedAt": "2024-10-11T02:44:45Z",
      "baseRepository": "ietf-wg-keytrans/draft-protocol",
      "baseRefName": "main",
      "baseRefOid": "12f569da33954320c48045bfb5f629e54774a55e",
      "headRepository": "ietf-wg-keytrans/draft-protocol",
      "headRefName": "tp-auditing",
      "headRefOid": "ce7ad760b27ddb560101df394a7affdcbce99073",
      "closedAt": "2024-10-11T02:44:45Z",
      "mergedAt": "2024-10-11T02:44:45Z",
      "mergedBy": "Bren2010",
      "mergeCommit": {
        "oid": "d71426e84c54e5c44455323c95b1f3b732ce1ccd"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 11,
      "id": "PR_kwDOLrnaA85-Stzw",
      "title": "Introduce idea of full vs abridged search proofs",
      "url": "https://github.com/ietf-wg-keytrans/draft-protocol/pull/11",
      "state": "MERGED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-10-11T02:43:23Z",
      "updatedAt": "2024-10-11T02:44:27Z",
      "baseRepository": "ietf-wg-keytrans/draft-protocol",
      "baseRefName": "tp-auditing",
      "baseRefOid": "35270e19711da2e3b2839da67c1cda25cc3ccda0",
      "headRepository": "ietf-wg-keytrans/draft-protocol",
      "headRefName": "brendan/tp-editorial",
      "headRefOid": "ea42541b18205e0325ef714303005a0f80afba26",
      "closedAt": "2024-10-11T02:44:27Z",
      "mergedAt": "2024-10-11T02:44:27Z",
      "mergedBy": "Bren2010",
      "mergeCommit": {
        "oid": "ce7ad760b27ddb560101df394a7affdcbce99073"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 12,
      "id": "PR_kwDOLrnaA86FtSCc",
      "title": "Support for strong authentication of time",
      "url": "https://github.com/ietf-wg-keytrans/draft-protocol/pull/12",
      "state": "MERGED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "- The main change here is to have each log entry contain the time it was created. This provides a stronger authentication of time compared to just signing it into the tree head and prevents certain classes of attacks.\r\n- Introduces the concept of a \"maximum lifetime\" for log entries. Essentially, if a log entry is too old, users will be able to see that and guide their search away from old portions of the tree, allowing them to be pruned.\r\n- Introduces the concept of a \"reasonable monitoring window\". This is the opposite of the \"maximum lifetime\" idea -- it allows users to tell when certain log entries have been added so recently that other users likely haven't had time to vet their contents. When users see that information has been added within the reasonable monitoring window, they maintain extra state about it to prevent/detect potential attacks. Similarly, when information is older than the reasonable monitoring window, it is taken more at face value.",
      "createdAt": "2024-12-18T23:02:49Z",
      "updatedAt": "2025-01-28T17:35:05Z",
      "baseRepository": "ietf-wg-keytrans/draft-protocol",
      "baseRefName": "main",
      "baseRefOid": "a610396bea5711d8c2975d2c4f41402c6a249d88",
      "headRepository": "ietf-wg-keytrans/draft-protocol",
      "headRefName": "brendan/time2",
      "headRefOid": "09620ce4f334505aa421236e9c62b916c21ff6a6",
      "closedAt": "2025-01-28T17:35:04Z",
      "mergedAt": "2025-01-28T17:35:04Z",
      "mergedBy": "Bren2010",
      "mergeCommit": {
        "oid": "115d6722d02f56beaf3acefa0504b2c9dc9545de"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOLrnaA86WpGrs",
          "commit": {
            "abbreviatedOid": "bc7098f"
          },
          "author": "thibmeu",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "this is a great addition. I have done a read, not an implementation. only minor comment, no blocker",
          "createdAt": "2025-01-02T10:45:30Z",
          "updatedAt": "2025-01-02T11:03:15Z",
          "comments": [
            {
              "originalPosition": 128,
              "body": "maybe point to the timestamp definition which appears much later in the document: Unix epoch in milliseconds.",
              "createdAt": "2025-01-02T10:45:30Z",
              "updatedAt": "2025-01-02T11:03:15Z"
            },
            {
              "originalPosition": 238,
              "body": "this is a great addition for readability",
              "createdAt": "2025-01-02T10:45:59Z",
              "updatedAt": "2025-01-02T11:03:15Z"
            },
            {
              "originalPosition": 281,
              "body": "consider aligning the wording with the `Configuration` defined below\r\n```\r\n  uint64 max_ahead;\r\n  unit64 max_behind;\r\n  uint64 reasonable_monitoring_window;\r\n  optional<uint64> maximum_lifetime;\r\n```\r\n\r\nfor instance, `how old of a view of` -> `how far behind`",
              "createdAt": "2025-01-02T10:49:10Z",
              "updatedAt": "2025-01-02T11:03:15Z"
            },
            {
              "originalPosition": 804,
              "body": "Unix epoch?",
              "createdAt": "2025-01-02T10:58:18Z",
              "updatedAt": "2025-01-02T11:03:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrnaA86XwGLf",
          "commit": {
            "abbreviatedOid": "bc7098f"
          },
          "author": "felixlinker",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "I like the changes and think they're a great addition. I have left some comments, but they are all on details.",
          "createdAt": "2025-01-13T08:20:18Z",
          "updatedAt": "2025-01-13T12:29:22Z",
          "comments": [
            {
              "originalPosition": 217,
              "body": "I find it unclear what \"the result\" exactly refers to here.",
              "createdAt": "2025-01-13T08:20:18Z",
              "updatedAt": "2025-01-13T12:29:22Z"
            },
            {
              "originalPosition": 251,
              "body": "Suggestion to replace the \"The full subtrees...\" sentence:\r\n> Full subtrees are the largest subtrees with size $2^n-1$ for some $n$.\r\n\r\nAs you define it now, a full subtree has all its subtrees as full subtrees too. I guess you don't want that.",
              "createdAt": "2025-01-13T08:24:42Z",
              "updatedAt": "2025-01-13T12:29:22Z"
            },
            {
              "originalPosition": 246,
              "body": "Unclear to me: What state does the user track overall? Here you say: \"about the last tree head they've observed.\" It might be more clear to say:\r\n> Clients retain the last tree head they've observed alongside some metadata, namely: [...]\r\n\r\nThis would make it clearer that this is all the user stores. (Additionally, I distinguished between client and user. But not sure you want that language.)",
              "createdAt": "2025-01-13T08:28:03Z",
              "updatedAt": "2025-01-13T12:29:22Z"
            },
            {
              "originalPosition": 264,
              "body": "```suggestion\r\n  direct path in the new implicit binary search tree.\r\n```",
              "createdAt": "2025-01-13T08:44:14Z",
              "updatedAt": "2025-01-13T12:29:22Z"
            },
            {
              "originalPosition": 380,
              "body": "I would break the paragraph before the \"However.\" I missed the last sentence when first reading the paragraph. I took the paragraph as \"example of how the binary ladder works,\" but the last sentence changes topic. That can be confusing.",
              "createdAt": "2025-01-13T08:51:10Z",
              "updatedAt": "2025-01-13T12:29:22Z"
            },
            {
              "originalPosition": 393,
              "body": "I don't get this. Reads like \"log omits proofs of inclusion [...] where proof of inclusion was already provided.\" Does it omit it or not? Or do you mean that you don't repeat proofs? (One query could contain queries for multiple versions or something similar.)",
              "createdAt": "2025-01-13T08:53:54Z",
              "updatedAt": "2025-01-13T12:29:22Z"
            },
            {
              "originalPosition": 396,
              "body": "I'm not sure whether this explanation adds much. It basically says \"it's fine,\" but doesn't say why. That's not a problem, but maybe saying nothing is better.",
              "createdAt": "2025-01-13T08:54:43Z",
              "updatedAt": "2025-01-13T12:29:22Z"
            },
            {
              "originalPosition": 410,
              "body": "\"Root log entry\" w.r.t. implicit binary search tree? If so, wouldn't it be more simple to say: \"The user may encounter expired log entries when searching the implicit binary search tree\"? Captures both cases. Is it necessary to distinguish root/not-root?",
              "createdAt": "2025-01-13T08:55:44Z",
              "updatedAt": "2025-01-13T12:29:22Z"
            },
            {
              "originalPosition": 425,
              "body": "Similarly to my comment above, it seems like one should be able to generalize the algorithm for both cases. It seems like its something along the lines of:\r\n```py\r\ndef recurse_search(node, search_target):\r\n  if node.matches(search_target):\r\n    return node\r\n  elif node.continue_right(search_target):\r\n    return recurse_search(node.right, search_target)\r\n  else:  # continue left\r\n    if node.expired:\r\n      throw ExpiredError()\r\n    else:\r\n      return recurse_search(node.left, search_target)\r\n```",
              "createdAt": "2025-01-13T09:01:54Z",
              "updatedAt": "2025-01-13T12:29:22Z"
            },
            {
              "originalPosition": 456,
              "body": "I don't understand what \"short of\" means here. Sentence seems clear without that.",
              "createdAt": "2025-01-13T09:09:08Z",
              "updatedAt": "2025-01-13T12:29:22Z"
            },
            {
              "originalPosition": 462,
              "body": "I think the \"largely\" is confusing here. Does it conclude the search or not? I would suggest to say something like:\r\n> Before returning the result, the client must also check some side-conditions, which are [...].",
              "createdAt": "2025-01-13T09:12:27Z",
              "updatedAt": "2025-01-13T12:29:22Z"
            },
            {
              "originalPosition": 461,
              "body": "Seems like there's something missing here.",
              "createdAt": "2025-01-13T09:14:09Z",
              "updatedAt": "2025-01-13T12:29:22Z"
            },
            {
              "originalPosition": 472,
              "body": "How can a binary ladder ever skip the target version?",
              "createdAt": "2025-01-13T09:15:16Z",
              "updatedAt": "2025-01-13T12:29:22Z"
            },
            {
              "originalPosition": 481,
              "body": "```suggestion\r\nentry that contains the target label-version pair. The purpose of\r\n```",
              "createdAt": "2025-01-13T09:16:53Z",
              "updatedAt": "2025-01-13T12:29:22Z"
            },
            {
              "originalPosition": 532,
              "body": "Why does the standard not suggest an algorithm to choose a distinguished log entry? Also, it's unclear to me whether distinguished log entries are defined per client or log and per label or globally.\r\n\r\nPS: Aha. Comes below. Maybe point out here that this will be defined next.\r\n\r\nPPS: From reading the algorithm below, I take that distinguished log entries are defined per log.",
              "createdAt": "2025-01-13T09:27:00Z",
              "updatedAt": "2025-01-13T12:29:22Z"
            },
            {
              "originalPosition": 570,
              "body": "```suggestion\r\nThe algorithm is initially called with these parameters: the\r\n```",
              "createdAt": "2025-01-13T09:33:44Z",
              "updatedAt": "2025-01-13T12:29:22Z"
            },
            {
              "originalPosition": 573,
              "body": "I think it would be clearer to move this before the algorithm definition above. For example, taking the difference in step 2 above and comparing that to RMW wasn't initially sensible to me. It makes sense now that I know you basically start with the difference being the log's lifetime.",
              "createdAt": "2025-01-13T09:34:24Z",
              "updatedAt": "2025-01-13T12:29:22Z"
            },
            {
              "originalPosition": 559,
              "body": "_Technically_, \"right/left timestamp\" is undefined. You defined \"timestamp of a log entry to its left/right.\" Could be taken as right/left timestamp of the log entry's respective children.",
              "createdAt": "2025-01-13T09:35:28Z",
              "updatedAt": "2025-01-13T12:29:22Z"
            },
            {
              "originalPosition": 568,
              "body": "I don't understand these two steps. Isn't the implicit binary search tree balanced s.t. if a node has a right child, it will also have a left child? If that is the case, doesn't this algorithm simply go to the left-most leaf?\r\n\r\nPS: Okay. I think I get it now. \"Assert\" means you basically create a list of distinguished entries. I took steps 3. and 4. as \"return recurse(...)\". It might make sense to make it explicit that this creates a list of distinguished log entries.",
              "createdAt": "2025-01-13T09:38:09Z",
              "updatedAt": "2025-01-13T12:29:22Z"
            },
            {
              "originalPosition": 560,
              "body": "I think \"assert\" is a confusing word as I take it to mean \"check.\" (As an assert in C++.) But if you agree with my comment below, I guess this will be changed anyways.",
              "createdAt": "2025-01-13T09:41:53Z",
              "updatedAt": "2025-01-13T12:29:22Z"
            },
            {
              "originalPosition": 592,
              "body": "I think this could be linked more clearly to the introduction of the monitoring section. Could be pointed out that this algorithm is intended to be run by non-owners to check that the server doesn't conceal what they've shown the user.",
              "createdAt": "2025-01-13T09:53:57Z",
              "updatedAt": "2025-01-13T12:29:22Z"
            },
            {
              "originalPosition": 626,
              "body": "I would say it *is* equivalent and thus shouldn't be repeated. I think you defined this as a fixed-version search. So why re-explain it here?",
              "createdAt": "2025-01-13T09:59:18Z",
              "updatedAt": "2025-01-13T12:29:22Z"
            },
            {
              "originalPosition": 291,
              "body": "I think it's a bit confusing to name this section \"Fixed-Version Searches\" when the \"Binary Ladder\" section below first defines the binary ladder in terms of searching for the most recent version of a label. Alternatively, you could call this section \"Version Searches\" and then provide two algorithms for fixed- and greatest-version search. I think the latter suggestion would be clearer as greatest-version search now sits between fixed-version search and monitoring. Why this split?\r\n\r\nPS: Aha. After having read Greatest-Version Search, I understand why the split. Nevertheless, I think it would make sense to rewrite the binary ladder section from the point of view of fixed-version search and make greatest-version search the exception.",
              "createdAt": "2025-01-13T10:02:40Z",
              "updatedAt": "2025-01-13T12:29:22Z"
            },
            {
              "originalPosition": 669,
              "body": "```suggestion\r\n1. Determine if the log entry is distinguished. If so, leave\r\n```",
              "createdAt": "2025-01-13T10:05:47Z",
              "updatedAt": "2025-01-13T12:29:22Z"
            },
            {
              "originalPosition": 671,
              "body": "```suggestion\r\n2. Compute the log entry's direct path in the implicit binary search\r\n```",
              "createdAt": "2025-01-13T10:06:13Z",
              "updatedAt": "2025-01-13T12:29:22Z"
            },
            {
              "originalPosition": 674,
              "body": "Terminate which list?",
              "createdAt": "2025-01-13T10:07:06Z",
              "updatedAt": "2025-01-13T12:29:22Z"
            },
            {
              "originalPosition": 675,
              "body": "Again: What list? (Skipping the rest. I'm a bit lost.)",
              "createdAt": "2025-01-13T10:07:27Z",
              "updatedAt": "2025-01-13T12:29:22Z"
            },
            {
              "originalPosition": 726,
              "body": "Unclear: the greatest version of the label _per subsequent distinguished log entry_? I presume so, but not explicit.",
              "createdAt": "2025-01-13T10:56:05Z",
              "updatedAt": "2025-01-13T12:29:22Z"
            },
            {
              "originalPosition": 736,
              "body": "```suggestion\r\nreceive a binary ladder for all distinguished log entries following the one\r\nthey've advertised. The Transparency Log provides whichever intermediate\r\n```",
              "createdAt": "2025-01-13T10:57:55Z",
              "updatedAt": "2025-01-13T12:29:22Z"
            },
            {
              "originalPosition": 763,
              "body": "Doesn't this contradict what is written in Binary Ladder? There, you get the full binary ladder.",
              "createdAt": "2025-01-13T11:32:32Z",
              "updatedAt": "2025-01-13T12:29:22Z"
            },
            {
              "originalPosition": 764,
              "body": "```suggestion\r\ngreatest version as the target in the rightmost distinguished log entry the root\r\nif there is no distinguished log entry yet.\r\n```\r\n\r\nFind this clearer as \"the search\" was ambiguous. (Prefix tree search (=binary ladder) or log tree search?)",
              "createdAt": "2025-01-13T11:34:43Z",
              "updatedAt": "2025-01-13T12:29:22Z"
            },
            {
              "originalPosition": 801,
              "body": "Doesn't really matter, but could also be seconds. I guess client/server clocks will not be sufficiently synchronized s.t. milliseconds can ever become relevant.",
              "createdAt": "2025-01-13T11:36:27Z",
              "updatedAt": "2025-01-13T12:29:22Z"
            },
            {
              "originalPosition": 1043,
              "body": "This sounds like `|timestampes| = |prefix_proofs| + |prefix_roots|`. If so, would it be an option to reflect that in the type? The `CombinedTreeProof` could be an array of structs where each struct has timestamp, and a prefix proof or a prefix root as an or type. Don't know whether the data language permits OR-types, though.\r\n\r\nPS: Aha. Okay. Doesn't seem like that. Seems like `|timestampes| < |prefix_proofs| + |prefix_roots|`.",
              "createdAt": "2025-01-13T11:48:57Z",
              "updatedAt": "2025-01-13T12:29:22Z"
            },
            {
              "originalPosition": 1052,
              "body": "What does it mean to \"have an entry in `prefix_proofs`\"? Not quite clear to me.",
              "createdAt": "2025-01-13T11:51:15Z",
              "updatedAt": "2025-01-13T12:29:22Z"
            },
            {
              "originalPosition": 1054,
              "body": "Hm. So repeated prefix proofs are identical. But why not repeat timestamps then, too?",
              "createdAt": "2025-01-13T11:51:56Z",
              "updatedAt": "2025-01-13T12:29:22Z"
            },
            {
              "originalPosition": 1087,
              "body": "```suggestion\r\n  - Otherwise, if the log entry's right child has also surpassed its\r\n    maximum lifetime, then a `PrefixProof` corresponding to a binary ladder in\r\n```\r\n\r\nSeems clearer to me this way as it's explicit that bullet point 3 is the else branch of bullet point 2.",
              "createdAt": "2025-01-13T11:58:17Z",
              "updatedAt": "2025-01-13T12:29:22Z"
            },
            {
              "originalPosition": 1089,
              "body": "```suggestion\r\n- If the `PrefixProof` from the first log entry containing the label-version\r\n```",
              "createdAt": "2025-01-13T11:59:06Z",
              "updatedAt": "2025-01-13T12:29:22Z"
            },
            {
              "originalPosition": 1090,
              "body": "What does \"the label-version pair\" refer to? The target? And what does \"touch\" mean? Doesn't every prefix proof \"touch\" the target as in it shows inclusion/non-inclusion?",
              "createdAt": "2025-01-13T12:00:26Z",
              "updatedAt": "2025-01-13T12:29:22Z"
            },
            {
              "originalPosition": 1211,
              "body": "I don't understand why there is a single binary ladder here. Don't we need multiple (for each node on the path in the implicit binary search tree to the leaf)? And aren't those provided in `search`?",
              "createdAt": "2025-01-13T12:10:34Z",
              "updatedAt": "2025-01-13T12:29:22Z"
            },
            {
              "originalPosition": 952,
              "body": "I found this section quite hard to parse, and I don't think I've fully understood it. It started clicking when I arrived at line 1486. You try to define a general data format to accommodate for multiple types of proofs.\r\n\r\nWould it maybe help to first list the use cases (i.e., what is included) and then generalize that into one data structure? The use-cases don't explicitly refer to the fields in the `CombinedTreeProof` data structure anyways.",
              "createdAt": "2025-01-13T12:17:20Z",
              "updatedAt": "2025-01-13T12:29:22Z"
            },
            {
              "originalPosition": 1254,
              "body": "What does \"verify\" mean here? I think: check for equality of the hash, no? I think that's short enough s.t. it can be made explicit.",
              "createdAt": "2025-01-13T12:19:06Z",
              "updatedAt": "2025-01-13T12:29:22Z"
            },
            {
              "originalPosition": 1264,
              "body": "I think the draft must specify that clients must check that the timestamp the log shows them is sufficiently close to their submission. Otherwise, all that will ever be checked is monotonicity.",
              "createdAt": "2025-01-13T12:21:56Z",
              "updatedAt": "2025-01-13T12:29:22Z"
            },
            {
              "originalPosition": 1454,
              "body": "Again, maybe worth pointing out that \"verify\" means \"check for equality.\"",
              "createdAt": "2025-01-13T12:27:23Z",
              "updatedAt": "2025-01-13T12:29:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrnaA86ZEmr4",
          "commit": {
            "abbreviatedOid": "bc7098f"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-01-22T19:41:52Z",
          "updatedAt": "2025-01-22T19:41:53Z",
          "comments": [
            {
              "originalPosition": 251,
              "body": "I maybe need a better term. A \"full subtree\" is any one with 2^n leaves. And then we say we want the smallest set possible of full subtrees that cover the full tree (the largest full subtrees possible).",
              "createdAt": "2025-01-22T19:41:52Z",
              "updatedAt": "2025-01-22T19:41:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrnaA86ZQaVO",
          "commit": {
            "abbreviatedOid": "bc7098f"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-01-23T23:11:33Z",
          "updatedAt": "2025-01-23T23:11:33Z",
          "comments": [
            {
              "originalPosition": 425,
              "body": "The issue is that, in some cases, we need to provide a proof from the prefix tree in an expired node. Whether or not depends on whether we started at an expired root, or we started at an unexpired node and recursed to an expired one.",
              "createdAt": "2025-01-23T23:11:33Z",
              "updatedAt": "2025-01-23T23:11:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrnaA86ZQ_Ca",
          "commit": {
            "abbreviatedOid": "bc7098f"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-01-24T00:03:10Z",
          "updatedAt": "2025-01-24T00:03:10Z",
          "comments": [
            {
              "originalPosition": 568,
              "body": "The implicit tree does not have the property that every non-leaf has both a left and right child.",
              "createdAt": "2025-01-24T00:03:10Z",
              "updatedAt": "2025-01-24T00:03:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrnaA86ZUAIm",
          "commit": {
            "abbreviatedOid": "bc7098f"
          },
          "author": "felixlinker",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-01-24T09:38:08Z",
          "updatedAt": "2025-01-24T09:38:08Z",
          "comments": [
            {
              "originalPosition": 568,
              "body": "Ah, makes sense! Still think it'd be beneficial to make it explicit that the algorithm computes a list.",
              "createdAt": "2025-01-24T09:38:08Z",
              "updatedAt": "2025-01-24T09:38:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrnaA86ZmciM",
          "commit": {
            "abbreviatedOid": "bc7098f"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-01-28T03:02:53Z",
          "updatedAt": "2025-01-28T03:02:53Z",
          "comments": [
            {
              "originalPosition": 763,
              "body": "Sorry, what is the contradiction?",
              "createdAt": "2025-01-28T03:02:53Z",
              "updatedAt": "2025-01-28T03:02:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrnaA86Zmd42",
          "commit": {
            "abbreviatedOid": "bc7098f"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-01-28T03:11:20Z",
          "updatedAt": "2025-01-28T03:11:21Z",
          "comments": [
            {
              "originalPosition": 804,
              "body": "No, these are durations not timestamps",
              "createdAt": "2025-01-28T03:11:20Z",
              "updatedAt": "2025-01-28T03:11:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrnaA86ZmiPw",
          "commit": {
            "abbreviatedOid": "bc7098f"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-01-28T03:34:51Z",
          "updatedAt": "2025-01-28T03:34:51Z",
          "comments": [
            {
              "originalPosition": 1054,
              "body": "The timestamps will always be the same, but repeated PrefixProofs may (will) be for different indices. So different PrefixProofs are valuable, but repeated timestamps are wasted space",
              "createdAt": "2025-01-28T03:34:51Z",
              "updatedAt": "2025-01-28T03:35:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrnaA86Zml6k",
          "commit": {
            "abbreviatedOid": "bc7098f"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-01-28T03:57:58Z",
          "updatedAt": "2025-01-28T03:57:58Z",
          "comments": [
            {
              "originalPosition": 1254,
              "body": "Will specify this more clearly in a follow-up PR",
              "createdAt": "2025-01-28T03:57:58Z",
              "updatedAt": "2025-01-28T03:57:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrnaA86ZmmSH",
          "commit": {
            "abbreviatedOid": "bc7098f"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-01-28T04:00:15Z",
          "updatedAt": "2025-01-28T04:00:15Z",
          "comments": [
            {
              "originalPosition": 1264,
              "body": "Verifying that the rightmost timestamp is sufficiently recent is part of verifying \"as if it were a SearchResponse for the most recent version of `label`\"",
              "createdAt": "2025-01-28T04:00:15Z",
              "updatedAt": "2025-01-28T04:00:16Z"
            }
          ]
        }
      ]
    },
    {
      "number": 13,
      "id": "PR_kwDOLrnaA86MrDXD",
      "title": "New definition of implicit binary search tree",
      "url": "https://github.com/ietf-wg-keytrans/draft-protocol/pull/13",
      "state": "MERGED",
      "author": "felixlinker",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I find the \"that doesn't take the computation out of bounds\" definition a bit counterintuitive. I think, a recursive definition is clearer so tried that! Let me know what you think! :)\r\n\r\nAlso, I find the sentence about odd/even numbered nodes confusing. I don't think this observation is necessary anywhere, so I would save our readers' energy.",
      "createdAt": "2025-02-26T16:20:42Z",
      "updatedAt": "2025-02-28T23:35:50Z",
      "baseRepository": "ietf-wg-keytrans/draft-protocol",
      "baseRefName": "main",
      "baseRefOid": "9bf448a1508983ae4e3ce13067044928da5c46a8",
      "headRepository": "ietf-wg-keytrans/draft-protocol",
      "headRefName": "ibst",
      "headRefOid": "45ce865cda5d1eb1842665fc7c08b6e457759f30",
      "closedAt": "2025-02-28T23:35:50Z",
      "mergedAt": "2025-02-28T23:35:50Z",
      "mergedBy": "Bren2010",
      "mergeCommit": {
        "oid": "fed8371f917dd1c1fc4d050e7cad7828cee23326"
      },
      "comments": [
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "I like this definition a lot! However, we can't do latex. I tried rewriting a bit myself but it got to be invasive, so please update with your preferred fix",
          "createdAt": "2025-02-27T19:59:48Z",
          "updatedAt": "2025-02-27T19:59:48Z"
        },
        {
          "author": "felixlinker",
          "authorAssociation": "COLLABORATOR",
          "body": "@Bren2010 Fixed! :) Glad you like it!",
          "createdAt": "2025-02-28T09:54:05Z",
          "updatedAt": "2025-02-28T09:54:05Z"
        },
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "Merging since this is editorial",
          "createdAt": "2025-02-28T23:35:48Z",
          "updatedAt": "2025-02-28T23:35:48Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOLrnaA86eEaAm",
          "commit": {
            "abbreviatedOid": "45ce865"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-02-28T23:35:27Z",
          "updatedAt": "2025-02-28T23:35:27Z",
          "comments": []
        }
      ]
    },
    {
      "number": 14,
      "id": "PR_kwDOLrnaA86MyVzC",
      "title": "Fix fixed-length vector notation",
      "url": "https://github.com/ietf-wg-keytrans/draft-protocol/pull/14",
      "state": "MERGED",
      "author": "felixlinker",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "As per [RFC 8446, Sec 3.4](https://datatracker.ietf.org/doc/html/rfc8446#section-3.4) fixed-length vectors are denoted by `[...]` not `<...>`. This PR fixes that notation.",
      "createdAt": "2025-02-27T11:57:03Z",
      "updatedAt": "2025-02-27T20:25:12Z",
      "baseRepository": "ietf-wg-keytrans/draft-protocol",
      "baseRefName": "main",
      "baseRefOid": "115d6722d02f56beaf3acefa0504b2c9dc9545de",
      "headRepository": "ietf-wg-keytrans/draft-protocol",
      "headRefName": "tls-notation",
      "headRefOid": "5c08fb7d2bb6eff12cfb133a08647e7c58335549",
      "closedAt": "2025-02-27T20:25:12Z",
      "mergedAt": "2025-02-27T20:25:11Z",
      "mergedBy": "Bren2010",
      "mergeCommit": {
        "oid": "d4a9bb09e8dd2c8c40c3df0d2684576c9ed77f11"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOLrnaA86d5KFX",
          "commit": {
            "abbreviatedOid": "5c08fb7"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thank you!",
          "createdAt": "2025-02-27T20:25:03Z",
          "updatedAt": "2025-02-27T20:25:03Z",
          "comments": []
        }
      ]
    },
    {
      "number": 17,
      "id": "PR_kwDOLrnaA86M1Xk5",
      "title": "Fix field reference",
      "url": "https://github.com/ietf-wg-keytrans/draft-protocol/pull/17",
      "state": "MERGED",
      "author": "felixlinker",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Addresses #16",
      "createdAt": "2025-02-27T17:38:05Z",
      "updatedAt": "2025-02-27T20:40:05Z",
      "baseRepository": "ietf-wg-keytrans/draft-protocol",
      "baseRefName": "main",
      "baseRefOid": "115d6722d02f56beaf3acefa0504b2c9dc9545de",
      "headRepository": "ietf-wg-keytrans/draft-protocol",
      "headRefName": "search-field-fix",
      "headRefOid": "56388f1409951c7aad6607fd8132fb7030ec0afb",
      "closedAt": "2025-02-27T20:40:05Z",
      "mergedAt": "2025-02-27T20:40:05Z",
      "mergedBy": "Bren2010",
      "mergeCommit": {
        "oid": "9bf448a1508983ae4e3ce13067044928da5c46a8"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 19,
      "id": "PR_kwDOLrnaA86M7rk1",
      "title": "Fix Wording in Updating the View of the Tree",
      "url": "https://github.com/ietf-wg-keytrans/draft-protocol/pull/19",
      "state": "MERGED",
      "author": "felixlinker",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The problem with the old phrasing is that the user did not advertise a log entry, they advertised a tree size. I think this should be the oldest node in the tree that corresponds to the user-advertised size.",
      "createdAt": "2025-02-28T12:27:45Z",
      "updatedAt": "2025-02-28T23:46:48Z",
      "baseRepository": "ietf-wg-keytrans/draft-protocol",
      "baseRefName": "main",
      "baseRefOid": "9bf448a1508983ae4e3ce13067044928da5c46a8",
      "headRepository": "ietf-wg-keytrans/draft-protocol",
      "headRefName": "updating-view",
      "headRefOid": "98e0d2e39ee2a78cfab6ceb45ac519d7b206b239",
      "closedAt": "2025-02-28T23:46:48Z",
      "mergedAt": "2025-02-28T23:46:48Z",
      "mergedBy": "Bren2010",
      "mergeCommit": {
        "oid": "c3a370bb0306fc52b90339185a802543cf2ddd60"
      },
      "comments": [
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "Merging as editorial",
          "createdAt": "2025-02-28T23:46:42Z",
          "updatedAt": "2025-02-28T23:46:42Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOLrnaA86eEcBu",
          "commit": {
            "abbreviatedOid": "a88ac1c"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-02-28T23:46:09Z",
          "updatedAt": "2025-02-28T23:46:09Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "```suggestion\r\n- Starting with the rightmost log entry from the tree that was advertised by\r\n  the user, compute its direct path in the new implicit binary\r\n```",
              "createdAt": "2025-02-28T23:46:09Z",
              "updatedAt": "2025-02-28T23:46:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrnaA86eEcGL",
          "commit": {
            "abbreviatedOid": "98e0d2e"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-02-28T23:46:31Z",
          "updatedAt": "2025-02-28T23:46:31Z",
          "comments": []
        }
      ]
    },
    {
      "number": 21,
      "id": "PR_kwDOLrnaA86NR-Kn",
      "title": "Shorter description of prefix proofs",
      "url": "https://github.com/ietf-wg-keytrans/draft-protocol/pull/21",
      "state": "MERGED",
      "author": "felixlinker",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I found the wording of:\r\n> The `prefix_proofs` array differs from the `timestamps` array in two important ways.\r\n\r\nConfusing because it is not specified how they are the same. Or put differently, it's silently assumed that `prefix_proofs` and `timestamps` are similar. I think it's clearer if we only describe how `prefix_proofs` is structured, and I used more spec-language (may, must, must not, etc.).",
      "createdAt": "2025-03-04T10:05:12Z",
      "updatedAt": "2025-03-04T20:35:11Z",
      "baseRepository": "ietf-wg-keytrans/draft-protocol",
      "baseRefName": "main",
      "baseRefOid": "c3a370bb0306fc52b90339185a802543cf2ddd60",
      "headRepository": "ietf-wg-keytrans/draft-protocol",
      "headRefName": "combined-tree-proof",
      "headRefOid": "046f9fb25ff741ed6f0c07701c6f98029dfc0cd5",
      "closedAt": "2025-03-04T20:35:11Z",
      "mergedAt": "2025-03-04T20:35:11Z",
      "mergedBy": "Bren2010",
      "mergeCommit": {
        "oid": "6fc4e91c0b8d9ed131476650da4e72e9a9c0d162"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOLrnaA86ee_Qf",
          "commit": {
            "abbreviatedOid": "0e32dbb"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-03-04T20:34:46Z",
          "updatedAt": "2025-03-04T20:34:46Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "```suggestion\r\n`prefix_proofs` or `prefix_roots` that correspond to log entries whose timestamps\r\nare not included in `timestamps` if the user is expected to have\r\nretained the timestamps from a previous query response.\r\n```",
              "createdAt": "2025-03-04T20:34:46Z",
              "updatedAt": "2025-03-04T20:34:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrnaA86ee_XW",
          "commit": {
            "abbreviatedOid": "046f9fb"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-03-04T20:35:02Z",
          "updatedAt": "2025-03-04T20:35:02Z",
          "comments": []
        }
      ]
    },
    {
      "number": 23,
      "id": "PR_kwDOLrnaA86OLCgL",
      "title": "Rework binary ladder and search algorithms",
      "url": "https://github.com/ietf-wg-keytrans/draft-protocol/pull/23",
      "state": "CLOSED",
      "author": "felixlinker",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "A number of changes concerning #20 and #22.\r\n\r\nI don't think the PR is fully ready set. In particular:\r\n- Consistency with other parts of the draft must be checked. In particular, \"Tree Proofs\" and \"User Operations\" may need to change.\r\n- I do not specify anymore really what the log server does, only what the client does. This may be okay. We could specify server behavior together with the datatypes.\r\n\r\nMy changes were motivated by the following.\r\n\r\n- I now give the binary ladder its own section. It didn't sit right with me that it was defined as part of the specific-version search, although it is used in the greatest-version search too.\r\n- Descriptions are now more algorithmic, i.e., less ambiguous. I think this is critical. Working this out wasn't trivial for me and we should reduce ambiguity.\r\n- The binary ladder is now an algorithm that is intended to be executed by clients. Thus, it doesn't make sense to say \"the server provides a binary ladder.\" I think we should adjust phrasing in the other parts of the spec to say that \"the server provides all inputs necessary to perform a binary ladder.\"\r\n\r\nLet me know what you think of the PR's direction!",
      "createdAt": "2025-03-11T14:05:56Z",
      "updatedAt": "2025-04-14T08:21:17Z",
      "baseRepository": "ietf-wg-keytrans/draft-protocol",
      "baseRefName": "main",
      "baseRefOid": "a4861ed31eb377326690ed84eed17cf3aceb7c2a",
      "headRepository": "ietf-wg-keytrans/draft-protocol",
      "headRefName": "binary-ladder",
      "headRefOid": "01c4dead616cee1075561c49118038bf82ce0913",
      "closedAt": "2025-04-14T08:21:17Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "> I now give the binary ladder its own section. It didn't sit right with me that it was defined as part of the specific-version search, although it is used in the greatest-version search too.\r\n\r\nBinary ladders are used in every algorithm: fixed-version, greatest-version, monitoring. The current organization is to build up one idea at a time in a productive way, so people see how the ideas fit together. The RMW, for example, is also used in greatest-version searches but is introduced in the monitoring section. If we were to pull all of these things out on their own, there would be a big bag of sections to read before anything useful is described.\r\n\r\n> Descriptions are now more algorithmic, i.e., less ambiguous. I think this is critical. Working this out wasn't trivial for me and we should reduce ambiguity.\r\n\r\nThe description you give of the binary ladder is more ambiguous to me. \"Check inclusion of version `x`... until the first version not to be included is found\" -- it's not clear that ending this step requires receiving and validating a non-inclusion proof. The description is also incorrect. If the target version is 7, I believe this will keep going unnecessarily.",
          "createdAt": "2025-03-11T17:55:28Z",
          "updatedAt": "2025-03-11T17:55:28Z"
        },
        {
          "author": "felixlinker",
          "authorAssociation": "COLLABORATOR",
          "body": "I tried clarifying the ambiguity of exponential offset in the initial step of the binary ladder with my most recent commit!\r\n\r\nI agree that my writing has less \"hand holding\" than your writing. This has pros and cons. During my implementation of the client, I noticed that I needed to think a lot about which steps the algorithms are supposed to take. I think this will lead to diverging implementations, and we should specify binary ladder/searches/etc. in more detail. So I think we must define the client algorithms in more detail.\r\n\r\nFor example, in my latest commit, I wasn't entirely sure what to do what to do if version 0 is not included, and such edge cases should be made explicit. While one can with a bit of thinking infer what should happen in case that immediately version 0 is found not-to-be-included, people might even forget about the edge case in the first place.\r\n\r\nWhat do you think about a super high-level overview section after the tree introductions? There we could say something like: \"Clients will run queries X, Y, Z. The server needs to provide the clients with the minimal data s.t. they have enough knowledge of the tree to run this query. Fixed version search is binary search on log tree to find committing leaf. Greatest version search is ....\" Then, we can use the dedicated sections to introduce the algorithms that the client runs, and the sections towards the end to define exact server-proof format.\r\n\r\nYou are also correct that I do not mention that server proofs are required for the binary ladder, but this was intentional. You can run this algorithm on a prefix tree independently of your view on the tree. You could get the entire tree or just the minimal tree that lets you exactly run the binary ladder. (This connects to the changes not having cascaded to the entire document.) In the proofs data structures later, I intend to change them to: \"The server provides all prefix tree hashes that let the client run the binary ladder as specified in X.\" (Or something similar.)",
          "createdAt": "2025-03-12T08:58:12Z",
          "updatedAt": "2025-03-12T08:58:12Z"
        },
        {
          "author": "felixlinker",
          "authorAssociation": "COLLABORATOR",
          "body": "Ah - and regarding binary ladder for greatest-version 7. How would the binary ladder run there? I find the current description ambiguous. We have the \"higher powers of two minus one part,\" which would lead to proof of inclusion of 7 and non-inclusion of 15. Do we do the binary search then? I guess we do. The spec simply says \"until it terminates\" but doesn't specify when to terminate. I say we terminate when we proved non-inclusion of 8 in this PR.",
          "createdAt": "2025-03-12T09:00:51Z",
          "updatedAt": "2025-03-12T09:00:51Z"
        },
        {
          "author": "felixlinker",
          "authorAssociation": "COLLABORATOR",
          "body": "I completely missed that there's an algorithm Section in the Fixed-Version Searches section. I will rework my changes to account for this.",
          "createdAt": "2025-03-12T12:23:47Z",
          "updatedAt": "2025-03-12T12:23:47Z"
        },
        {
          "author": "felixlinker",
          "authorAssociation": "COLLABORATOR",
          "body": "@Bren2010 Thought a bit more about this. What do you think about leaving the original sections mostly as is, but providing an \"Algorithms\" section (somewhere around current sections 9-11) that is more formal? Then people can have both the introduction as is and more clearly specified algorithms.\r\n\r\nI would disambiguate the term \"binary ladder\" still though as its used with slightly different meanings over the document.",
          "createdAt": "2025-03-19T07:27:41Z",
          "updatedAt": "2025-03-19T07:27:41Z"
        },
        {
          "author": "felixlinker",
          "authorAssociation": "COLLABORATOR",
          "body": "Closed in favor of #31 ",
          "createdAt": "2025-04-14T08:21:17Z",
          "updatedAt": "2025-04-14T08:21:17Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 26,
      "id": "PR_kwDOLrnaA86OVqRS",
      "title": "Change order of PrefixProof.results",
      "url": "https://github.com/ietf-wg-keytrans/draft-protocol/pull/26",
      "state": "MERGED",
      "author": "felixlinker",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I think changing the order this way would simplify implementation as clients can directly infer which results targets which index. This spares implementations from sorting `SearchResponse.binary_ladder`. Instead, they can just zip the two arrays (speaking functionally).",
      "createdAt": "2025-03-12T12:39:01Z",
      "updatedAt": "2025-04-17T18:17:51Z",
      "baseRepository": "ietf-wg-keytrans/draft-protocol",
      "baseRefName": "main",
      "baseRefOid": "8d661713e4bf1a0cd10c51d1f41fbbc45ad9c32f",
      "headRepository": "ietf-wg-keytrans/draft-protocol",
      "headRefName": "prefix-proof-results",
      "headRefOid": "d704d87c459e73794489c66fde9adffea3626f46",
      "closedAt": "2025-04-17T18:17:51Z",
      "mergedAt": "2025-04-17T18:17:51Z",
      "mergedBy": "Bren2010",
      "mergeCommit": {
        "oid": "80dc7cfdc6a3c3bee096ffba33baf2bc5034288b"
      },
      "comments": [
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "I am not wholly opposed to this, but want to clarify one thing:\r\n\r\n> This spares implementations from sorting `SearchResponse.binary_ladder`\r\n\r\nThis is not true. Users will always need to sort SearchResponse.binary_ladder because the prefix tree itself is sorted lexicographically, and users need to know in what order to hash together the node values in PrefixProof.elements.\r\n\r\nGiven that, is this still worth it in your opinion?",
          "createdAt": "2025-03-12T19:59:50Z",
          "updatedAt": "2025-03-12T19:59:50Z"
        },
        {
          "author": "felixlinker",
          "authorAssociation": "COLLABORATOR",
          "body": "Is it though? In my implementation, if this were to change, I wouldn't need to sort the leaves. What I do in my implementation is the following: For all leaves in `SearchResponse.binary_ladder`, iI transform them to a VRF output and \"default insert them as leaves.\" That is, I walk a partial prefix tree data structure, initializing inner nodes where necessary along the way. After that, I DFS the prefix tree left-to-right and take the provided hashes from the array in the prefix tree proof structure. I guess you could be marginally more efficient, but this was the easiest to implement for me and requires no sorting. Is it correct, though?",
          "createdAt": "2025-03-17T03:43:40Z",
          "updatedAt": "2025-03-17T03:43:40Z"
        },
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "It's correct, but it is also definitely sorting :) When you do your depth-first left-to-right search, could you not pull the PrefixProof.results entries in similar to how you pull PrefixProof.elements entries in?",
          "createdAt": "2025-03-21T23:01:35Z",
          "updatedAt": "2025-03-21T23:01:35Z"
        },
        {
          "author": "felixlinker",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree that this would be sorting. I see how there can be a DFS-traversal algorithm that in linear (in the number of leaves and co-path nodes) builds the prefix tree. I know take twice that time for the sake of ease of implementation. Not sure what is to be preferred. No strong opinion anymore :)",
          "createdAt": "2025-04-14T16:51:07Z",
          "updatedAt": "2025-04-14T16:51:07Z"
        },
        {
          "author": "felixlinker",
          "authorAssociation": "COLLABORATOR",
          "body": "@Bren2010 Okay, made up my mind! For the construction of the prefix tree, order does not matter as you need to sort it one way or the other (as you pointed out). But for checking the proofs after prefix tree construction, it's actually much nicer if it's in the order of the binary ladder. Then you can just zip the entire thing.\r\n\r\nI guess, there's one super clever algorithm that does prefix tree construction and ladder verification in one go, but we aim to keep that separate for verification purposes :)",
          "createdAt": "2025-04-17T12:28:03Z",
          "updatedAt": "2025-04-17T12:28:03Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOLrnaA86lf0-U",
          "commit": {
            "abbreviatedOid": "d704d87"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-04-17T18:17:46Z",
          "updatedAt": "2025-04-17T18:17:46Z",
          "comments": []
        }
      ]
    },
    {
      "number": 30,
      "id": "PR_kwDOLrnaA86OWhO3",
      "title": "Tree node values",
      "url": "https://github.com/ietf-wg-keytrans/draft-protocol/pull/30",
      "state": "OPEN",
      "author": "felixlinker",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "PR provides a complete algorithm to determine a prefix and log tree node values.\r\n\r\nCloses #27 and closes #28.\r\n\r\nRelated to #29 as I'm using `undefined` here.",
      "createdAt": "2025-03-12T14:02:19Z",
      "updatedAt": "2025-03-17T03:41:19Z",
      "baseRepository": "ietf-wg-keytrans/draft-protocol",
      "baseRefName": "main",
      "baseRefOid": "8d661713e4bf1a0cd10c51d1f41fbbc45ad9c32f",
      "headRepository": "ietf-wg-keytrans/draft-protocol",
      "headRefName": "prefix-tree-values",
      "headRefOid": "454fbf420fc256f6d546c4c56acc6cac07befa17",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "I feel like this new code is more complicated and loses a lot of the pedagogical value. It's pseudocode -- it doesn't need to compile, you just need to know what it means. And you did!\r\n\r\n> node.value is not defined. It is implicitly clear from context that this should be LogLeaf and PrefixLeaf, but it should be made explicit.\r\n\r\nIt is explicitly defined. The text says that every node in these trees has a value. We say exactly how to compute the byte string value of a leaf node from LogLeaf/PrefixLeaf, and how to compute the byte string value of a parent node.",
          "createdAt": "2025-03-14T08:11:04Z",
          "updatedAt": "2025-03-14T08:11:04Z"
        },
        {
          "author": "felixlinker",
          "authorAssociation": "COLLABORATOR",
          "body": "I think the pedagogical value of the text preceding the changed parts is unchanged (as the text is unchanged). It took me quite some time to figure out when exactly the hash function is applied because I kept recursing on the definition of `.value` depending on the type of node. And also, the node type is not defined explicitly.\r\n\r\nI think it's important to have the spec be as clear as possible. It should require as little effort as possible to parse and implement it.",
          "createdAt": "2025-03-17T03:41:18Z",
          "updatedAt": "2025-03-17T03:41:18Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 31,
      "id": "PR_kwDOLrnaA86P5_z4",
      "title": "Be more explicit about binary ladder contents",
      "url": "https://github.com/ietf-wg-keytrans/draft-protocol/pull/31",
      "state": "MERGED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR:\r\n- Adds a new top-level section on binary ladders\r\n- Adds a subsection to each algorithm (fixed-version / greatest-version search, monitor) explaining the specific binary ladder for this algorithm\r\n- Avoids sending unnecessary lookups in monitor algorithm\r\n- Avoids not sending necessary lookups in greatest-version search algorithm\r\n\r\n@felixlinker Let me know your thoughts / if this addresses the same concerns as #23 ",
      "createdAt": "2025-03-24T17:11:41Z",
      "updatedAt": "2025-04-05T02:55:27Z",
      "baseRepository": "ietf-wg-keytrans/draft-protocol",
      "baseRefName": "main",
      "baseRefOid": "dc6993c5107a7c76ff963188c9cce9ebf2adff3e",
      "headRepository": "ietf-wg-keytrans/draft-protocol",
      "headRefName": "brendan/binary-ladder",
      "headRefOid": "3428996a60639c487cb7a344d317a47e7042a80f",
      "closedAt": "2025-04-05T02:55:27Z",
      "mergedAt": "2025-04-05T02:55:27Z",
      "mergedBy": "Bren2010",
      "mergeCommit": {
        "oid": "0f1de4a8be2bb914849b3f9cef318471bdcd678a"
      },
      "comments": [
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "Added algorithms for the binary ladders",
          "createdAt": "2025-04-05T02:55:20Z",
          "updatedAt": "2025-04-05T02:55:20Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOLrnaA86h-i5u",
          "commit": {
            "abbreviatedOid": "2dc3a67"
          },
          "author": "felixlinker",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks for taking the time to draft this! I think this PR is good! I didn't have time to think about whether all the specification parts are correct/accurate, but the changes definitely go into a direction addressing what I tried addressing in #23.\r\n\r\nI still think there are some issues that will make the draft harder to implement, and there's still ambiguous wording on what a binary ladder is.\r\n\r\nI think we do need precise algorithms on binary ladders. Happy to put them in the Appendix. I think we both need an explanation with reasoning (as we already have it), and \"dry\" descriptions. Ideally, an engineer should be able to implement a draft without thinking too much about it.\r\n\r\nAs for the wording, you define a binary ladder initially as \"a serious of lookups,\" but then later go on to say that \"the server provides a binary ladder.\" I know what you mean with both, but I think we can use more precise language here.\r\n\r\nBoth my above comments, though, don't block merging the PR :)",
          "createdAt": "2025-03-26T14:43:35Z",
          "updatedAt": "2025-03-26T14:43:35Z",
          "comments": []
        }
      ]
    },
    {
      "number": 32,
      "id": "PR_kwDOLrnaA86QtR6W",
      "title": "Describe balanced prefix tree",
      "url": "https://github.com/ietf-wg-keytrans/draft-protocol/pull/32",
      "state": "CLOSED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-03-30T23:36:46Z",
      "updatedAt": "2025-05-03T23:35:47Z",
      "baseRepository": "ietf-wg-keytrans/draft-protocol",
      "baseRefName": "main",
      "baseRefOid": "dc6993c5107a7c76ff963188c9cce9ebf2adff3e",
      "headRepository": "ietf-wg-keytrans/draft-protocol",
      "headRefName": "brendan/balanced-pt",
      "headRefOid": "9e02e6c9361eaed7e7aac3b8a9ada7561d57994b",
      "closedAt": "2025-05-03T23:35:47Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOLrnaA86j5Uvq",
          "commit": {
            "abbreviatedOid": "a420db4"
          },
          "author": "felixlinker",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "I like it!\r\n\r\nI added some editorial feedback.",
          "createdAt": "2025-04-08T11:57:55Z",
          "updatedAt": "2025-04-08T12:10:04Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "```suggestion\r\nrepresents is based on its **midpoint** and the **first unspecified\r\n```",
              "createdAt": "2025-04-08T11:57:55Z",
              "updatedAt": "2025-04-08T12:10:04Z"
            },
            {
              "originalPosition": 17,
              "body": "\"Initially, ...\" - Initially when compared to what point in time?",
              "createdAt": "2025-04-08T12:01:28Z",
              "updatedAt": "2025-04-08T12:10:04Z"
            },
            {
              "originalPosition": 19,
              "body": "```suggestion\r\nvalue chosen by the Transparency Log such that it bisects the possible values for the\r\n```\r\n\r\n\"Chosen by the transparency log\" sounds like the log can choose arbitrary values. Is this phrasing more accurate?",
              "createdAt": "2025-04-08T12:06:17Z",
              "updatedAt": "2025-04-08T12:10:04Z"
            },
            {
              "originalPosition": 14,
              "body": "The sentence doesn't \"type check\" for me. A prefix tree's inner node does not represent a single search key, right? It represents a set of search keys. It doesn't work for me to say \"what a parent node is based on *the* search key.\"",
              "createdAt": "2025-04-08T12:07:37Z",
              "updatedAt": "2025-04-08T12:10:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrnaA86kcFbg",
          "commit": {
            "abbreviatedOid": "a420db4"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-04-10T23:58:13Z",
          "updatedAt": "2025-04-10T23:58:13Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "It can in fact choose arbitrary values. So an evil Transparency Log can make search paths longer",
              "createdAt": "2025-04-10T23:58:13Z",
              "updatedAt": "2025-04-10T23:58:13Z"
            }
          ]
        }
      ]
    },
    {
      "number": 35,
      "id": "PR_kwDOLrnaA86ShGcX",
      "title": "Editorial changes",
      "url": "https://github.com/ietf-wg-keytrans/draft-protocol/pull/35",
      "state": "MERGED",
      "author": "felixlinker",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Should be self-explanatory :) Happy to answer questions!",
      "createdAt": "2025-04-14T16:49:28Z",
      "updatedAt": "2025-04-17T18:27:02Z",
      "baseRepository": "ietf-wg-keytrans/draft-protocol",
      "baseRefName": "main",
      "baseRefOid": "0f1de4a8be2bb914849b3f9cef318471bdcd678a",
      "headRepository": "ietf-wg-keytrans/draft-protocol",
      "headRefName": "felixlinker/editorial",
      "headRefOid": "bbaa3e9c592c0c4dfcfc8ddf5131a03f02460316",
      "closedAt": "2025-04-17T18:27:02Z",
      "mergedAt": "2025-04-17T18:27:02Z",
      "mergedBy": "Bren2010",
      "mergeCommit": {
        "oid": "7370f25364caefc9aca3bd8c4e2c9fb48ec3d8b2"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOLrnaA86lf4p5",
          "commit": {
            "abbreviatedOid": "5424a8a"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-04-17T18:25:35Z",
          "updatedAt": "2025-04-17T18:26:34Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\r\n{: title=\"Illustration of a consistency proof between a log with 4 and with 6\r\n```",
              "createdAt": "2025-04-17T18:25:35Z",
              "updatedAt": "2025-04-17T18:26:34Z"
            },
            {
              "originalPosition": 23,
              "body": "```suggestion\r\n  log. The Transparency Log provides the minimum set of head values from\r\n```",
              "createdAt": "2025-04-17T18:26:13Z",
              "updatedAt": "2025-04-17T18:26:34Z"
            }
          ]
        }
      ]
    },
    {
      "number": 39,
      "id": "PR_kwDOLrnaA86TJChp",
      "title": "Improve algorithm descriptions",
      "url": "https://github.com/ietf-wg-keytrans/draft-protocol/pull/39",
      "state": "MERGED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "- More explicitly specify greatest-version search.\r\n- Prevent needing multiple PrefixProofs from the same log entry when monitoring\r\n- Specify prefix tree depth is zero-indexed (closes #37)\r\n- Move InclusionProof into CombinedTreeProof\r\n\r\nNo \"real\" protocol changes, this is mostly editorial",
      "createdAt": "2025-04-18T16:25:45Z",
      "updatedAt": "2025-04-24T22:07:05Z",
      "baseRepository": "ietf-wg-keytrans/draft-protocol",
      "baseRefName": "main",
      "baseRefOid": "7370f25364caefc9aca3bd8c4e2c9fb48ec3d8b2",
      "headRepository": "ietf-wg-keytrans/draft-protocol",
      "headRefName": "brendan/algs",
      "headRefOid": "1c2a03903c3c9ba5256a22869a03c3bd50bf0e4a",
      "closedAt": "2025-04-24T22:07:05Z",
      "mergedAt": "2025-04-24T22:07:05Z",
      "mergedBy": "Bren2010",
      "mergeCommit": {
        "oid": "629f05fa40d825c030b02205f9809683e2233935"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOLrnaA86l5dfs",
          "commit": {
            "abbreviatedOid": "58fae4f"
          },
          "author": "felixlinker",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-04-22T08:35:42Z",
          "updatedAt": "2025-04-22T09:03:19Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "I still have my gripes with this \"this largely concludes the search.\" I think that implementors will wonder how it exactly informs implementation.",
              "createdAt": "2025-04-22T08:35:42Z",
              "updatedAt": "2025-04-22T09:03:19Z"
            },
            {
              "originalPosition": 64,
              "body": "```suggestion\r\n   1. Check if a binary ladder for this log entry was already provided in the\r\n```\r\n\r\nIs \"from\" the preposition we typically use? Seemed off.",
              "createdAt": "2025-04-22T08:39:23Z",
              "updatedAt": "2025-04-22T09:03:19Z"
            },
            {
              "originalPosition": 69,
              "body": "```suggestion\r\n         needs to be monitored. Remove the position-version pair with the\r\n         lesser version from the map and move on to the next map\r\n```",
              "createdAt": "2025-04-22T08:40:15Z",
              "updatedAt": "2025-04-22T09:03:19Z"
            },
            {
              "originalPosition": 136,
              "body": "```suggestion\r\n   Verify that the binary ladder indicates a maximum version greater than or\r\n   equal to that of its parent log entry.\r\n```\r\n\r\nThis text seems simpler and should say the same. I think the \"accounting for any inclusion or non-inclusion proofs\" can be confusing as the connection to the rest of the paragraph is only implicit.",
              "createdAt": "2025-04-22T08:44:50Z",
              "updatedAt": "2025-04-22T09:03:19Z"
            },
            {
              "originalPosition": 136,
              "body": "What should be done in step 3 at the first log entry? Probably, one should verify that indicated version is >= than any previously queried versions. \"Parent\" is an ambiguous reference for the first entry the algorithm checks.",
              "createdAt": "2025-04-22T08:46:06Z",
              "updatedAt": "2025-04-22T09:03:19Z"
            },
            {
              "originalPosition": 138,
              "body": "```suggestion\r\n   way that proves the target version to be the greatest that\r\n```",
              "createdAt": "2025-04-22T08:47:38Z",
              "updatedAt": "2025-04-22T09:03:19Z"
            },
            {
              "originalPosition": 142,
              "body": "```suggestion\r\n   exists. This means that it correctly targets the greatest version provided in\r\n   the log response (as specified in {{binary-ladder}}) and does not terminate\r\n   early.\r\n```\r\n\r\nI think the previous specification was confusing. It did not reference the original binary ladder section (fine) but did specify some algorithmic steps, which would be insufficient just by themselves. E.g., `0-inclusion, 6-inclusion, 10-non-inclusion` satisfy the checks of inclusion/non-inclusion and some may take it as \"not terminating early.\"\r\n\r\nI think we're better off referencing the binary ladder section and not adding an incomplete list of checks to perform.",
              "createdAt": "2025-04-22T08:57:08Z",
              "updatedAt": "2025-04-22T09:03:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrnaA86mdBFF",
          "commit": {
            "abbreviatedOid": "58fae4f"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-04-24T22:04:46Z",
          "updatedAt": "2025-04-24T22:04:46Z",
          "comments": [
            {
              "originalPosition": 142,
              "body": "These checks are sufficient though? If we make every expected binary ladder lookup without terminating early, that means every lookup except the last one definitely returned the expected result. We just have to check the last one based on whether it's for a version greater than / equal / less than the target version.",
              "createdAt": "2025-04-24T22:04:46Z",
              "updatedAt": "2025-04-24T22:04:46Z"
            }
          ]
        }
      ]
    },
    {
      "number": 40,
      "id": "PR_kwDOLrnaA86T1kui",
      "title": "More information on tree heads",
      "url": "https://github.com/ietf-wg-keytrans/draft-protocol/pull/40",
      "state": "MERGED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "- I've been informed that ciphersuite is not a word :/\r\n- Specify FullTreeHead, AuditorTreeHead",
      "createdAt": "2025-04-24T22:24:35Z",
      "updatedAt": "2025-05-03T23:34:50Z",
      "baseRepository": "ietf-wg-keytrans/draft-protocol",
      "baseRefName": "main",
      "baseRefOid": "629f05fa40d825c030b02205f9809683e2233935",
      "headRepository": "ietf-wg-keytrans/draft-protocol",
      "headRefName": "brendan/tree-head",
      "headRefOid": "e0cd890aa87d8531e69e1c9440f547f0c2750c93",
      "closedAt": "2025-05-03T23:34:49Z",
      "mergedAt": "2025-05-03T23:34:49Z",
      "mergedBy": "Bren2010",
      "mergeCommit": {
        "oid": "f14ad7fe5987611e85fd716dc7d27c5f9133fb44"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOLrnaA86mgOFT",
          "commit": {
            "abbreviatedOid": "e0cd890"
          },
          "author": "felixlinker",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-04-25T09:03:19Z",
          "updatedAt": "2025-04-25T09:03:19Z",
          "comments": []
        }
      ]
    },
    {
      "number": 41,
      "id": "PR_kwDOLrnaA86U-Lsm",
      "title": "Write up how third-party auditing / management work",
      "url": "https://github.com/ietf-wg-keytrans/draft-protocol/pull/41",
      "state": "OPEN",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This approach to third-party auditing is not really secure in terms of how it interacts with the monitoring algorithm. But I've been too indecisive in figuring out how I want to update the monitoring algorithm, so opening this now and I'll fix monitoring later.",
      "createdAt": "2025-05-05T17:22:15Z",
      "updatedAt": "2025-06-19T16:26:12Z",
      "baseRepository": "ietf-wg-keytrans/draft-protocol",
      "baseRefName": "main",
      "baseRefOid": "cfd5d04905c001fefa8aca6edb77fb502e37e48f",
      "headRepository": "ietf-wg-keytrans/draft-protocol",
      "headRefName": "brendan/auditing",
      "headRefOid": "ad9ff1eb0dddda1062c4b7283545f99fecaa676c",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOLrnaA86qfEC0",
          "commit": {
            "abbreviatedOid": "bc89865"
          },
          "author": "felixlinker",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "I think auditing needs a bit more context, e.g., how it is supposed to work out in the grand scheme of things, how it affects client operations, and which APIs there are.\r\n\r\nBut written text is good! Just don't think it makes much sense to add it in isolation.",
          "createdAt": "2025-05-22T08:24:53Z",
          "updatedAt": "2025-05-22T08:33:22Z",
          "comments": [
            {
              "originalPosition": 159,
              "body": "Why \"at least one\"? Why not \"the most recent\"?",
              "createdAt": "2025-05-22T08:24:53Z",
              "updatedAt": "2025-05-22T08:33:22Z"
            },
            {
              "originalPosition": 159,
              "body": "```suggestion\r\n   entry, the prefix tree leaf was published in at least one\r\n```",
              "createdAt": "2025-05-22T08:25:02Z",
              "updatedAt": "2025-05-22T08:33:22Z"
            },
            {
              "originalPosition": 124,
              "body": "You say that each entry \"has a corresponding `AuditorUpdate` structure. I find it unclear what that means. Will it be added to the log tree itself? I presume not as it is sufficient to show this to single auditors and need not be committed to. Maybe \"`AuditorUpdate` structures correspond to log tree entries and ...\". Or say that auditors can request them.",
              "createdAt": "2025-05-22T08:28:11Z",
              "updatedAt": "2025-05-22T08:33:22Z"
            },
            {
              "originalPosition": 137,
              "body": "Assuming that these are served to auditors individually, and directly, it may be nice to allow logs to show diffs for more than one log entry, e.g., auditor last checked `n`, and log presents update for `n+m`. This should be easily doable by adding a `uint64 delta_to` field.",
              "createdAt": "2025-05-22T08:30:00Z",
              "updatedAt": "2025-05-22T08:33:22Z"
            },
            {
              "originalPosition": 120,
              "body": "```suggestion\r\nsignatures from a Third-Party Auditor attesting to the fact that the\r\n```\r\n\r\nPartially personal preference. \"Lightweight\" is such an overused term and conveys little meaning. But also: I don't think auditors will be particularly lightweight, no? They may need to perform a lot of computations to check tree construction.",
              "createdAt": "2025-05-22T08:31:02Z",
              "updatedAt": "2025-05-22T08:33:22Z"
            },
            {
              "originalPosition": 117,
              "body": "I think this section deserves a bit more context as to how auditing is supposed to work out, e.g., say that \"auditors will check append-only property at a regular basis,\" etc.",
              "createdAt": "2025-05-22T08:32:21Z",
              "updatedAt": "2025-05-22T08:33:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrnaA86uXEhp",
          "commit": {
            "abbreviatedOid": "bc89865"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-13T15:41:25Z",
          "updatedAt": "2025-06-13T15:41:26Z",
          "comments": [
            {
              "originalPosition": 117,
              "body": "Background info I think is more appropriate for the arch document. I looked in the arch docu and we're pretty thin on how we describe auditing there too, so I will flesh it out separately",
              "createdAt": "2025-06-13T15:41:25Z",
              "updatedAt": "2025-06-13T15:41:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrnaA86uXJNy",
          "commit": {
            "abbreviatedOid": "bc89865"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-13T15:44:27Z",
          "updatedAt": "2025-06-13T15:44:28Z",
          "comments": [
            {
              "originalPosition": 137,
              "body": "I'm not sure what you mean here?",
              "createdAt": "2025-06-13T15:44:27Z",
              "updatedAt": "2025-06-13T15:44:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrnaA86uXK9E",
          "commit": {
            "abbreviatedOid": "bc89865"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-13T15:46:53Z",
          "updatedAt": "2025-06-13T15:46:53Z",
          "comments": [
            {
              "originalPosition": 159,
              "body": "It's possible that if we add a new log entry, that new log entry will be distinguished immediately. This happens for example if the RMW is 0. That would make it the most recent distinguished log entry. But we just removed this search key from it, so it's not in the \"most recent\" distinguished log entry",
              "createdAt": "2025-06-13T15:46:53Z",
              "updatedAt": "2025-06-13T15:46:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrnaA86usJXd",
          "commit": {
            "abbreviatedOid": "f2d9c1b"
          },
          "author": "felixlinker",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-16T06:40:30Z",
          "updatedAt": "2025-06-16T06:40:30Z",
          "comments": [
            {
              "originalPosition": 117,
              "body": "We have a lot of introductory/glue text in other sections already, and I think this is a strength of the draft. Why not just a small intro to third-party management and auditing as intro text to the section \"Third Parties\"? I think we could be very succinct here, but this would help readers.",
              "createdAt": "2025-06-16T06:40:30Z",
              "updatedAt": "2025-06-16T06:40:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrnaA86usKcS",
          "commit": {
            "abbreviatedOid": "f2d9c1b"
          },
          "author": "felixlinker",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-16T06:42:37Z",
          "updatedAt": "2025-06-16T06:42:37Z",
          "comments": [
            {
              "originalPosition": 137,
              "body": "This structure is basically a diff, right? The `timestamp` field encodes the newer version of the diff. My assumption was: Since the structure does not define a field for the older version, the diff is to the previous version (i.e., this structure will always represent a diff from epoch `n` to epoch `n+1`).\r\n\r\nI think it would be better to allow for flexibility here and allow auditors to sign off diffs between epochs `n` and `n+m`. For that, we need two timestamps.",
              "createdAt": "2025-06-16T06:42:37Z",
              "updatedAt": "2025-06-16T06:42:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrnaA86vcTDA",
          "commit": {
            "abbreviatedOid": "f2d9c1b"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-19T15:20:59Z",
          "updatedAt": "2025-06-19T15:20:59Z",
          "comments": [
            {
              "originalPosition": 137,
              "body": "Oh, I don't think it would be secure to batch diffs like that. The auditor has to go through each AuditorUpdate one at a time to make sure the corresponding log entry is acceptable / won't give a false view to users.",
              "createdAt": "2025-06-19T15:20:59Z",
              "updatedAt": "2025-06-19T15:20:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrnaA86vc8YQ",
          "commit": {
            "abbreviatedOid": "bc89865"
          },
          "author": "felixlinker",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-19T16:26:11Z",
          "updatedAt": "2025-06-19T16:26:12Z",
          "comments": [
            {
              "originalPosition": 137,
              "body": "I know that auditors must process every epoch. But they could batch their results to users! (Promising that they indeed processed all epochs in the delta.)",
              "createdAt": "2025-06-19T16:26:12Z",
              "updatedAt": "2025-06-19T16:26:12Z"
            }
          ]
        }
      ]
    },
    {
      "number": 42,
      "id": "PR_kwDOLrnaA86V7T6w",
      "title": "Write security considerations, cipher suites registry",
      "url": "https://github.com/ietf-wg-keytrans/draft-protocol/pull/42",
      "state": "OPEN",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-05-13T03:07:54Z",
      "updatedAt": "2025-06-19T15:01:55Z",
      "baseRepository": "ietf-wg-keytrans/draft-protocol",
      "baseRefName": "main",
      "baseRefOid": "cfd5d04905c001fefa8aca6edb77fb502e37e48f",
      "headRepository": "ietf-wg-keytrans/draft-protocol",
      "headRefName": "brendan/back-matter",
      "headRefOid": "0bf1f1da9f35a2378b039b9631544302d9704ea4",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOLrnaA86qfLHY",
          "commit": {
            "abbreviatedOid": "6f2460d"
          },
          "author": "felixlinker",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "It seems to me that the KT Cipher Suites section would be better off as its own RFC. Just like the JWT spec is distinct from the JWA spec.",
          "createdAt": "2025-05-22T08:34:08Z",
          "updatedAt": "2025-05-22T09:02:41Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "```suggestion\r\ninitially created, that specifies the following primitives and parameters for\r\ncryptographic computations:\r\n```",
              "createdAt": "2025-05-22T08:34:09Z",
              "updatedAt": "2025-05-22T09:02:41Z"
            },
            {
              "originalPosition": 15,
              "body": "```suggestion\r\ninitially created, that specifies the following primitives and parameters for\r\ncryptographic computations:\r\n```",
              "createdAt": "2025-05-22T08:36:39Z",
              "updatedAt": "2025-05-22T09:02:42Z"
            },
            {
              "originalPosition": 40,
              "body": "```suggestion\r\nunexpected or malicious modifications to their account. Users that go offline\r\nfor longer than the maximum log entry lifetime may not detect that the log\r\ninserted malicious entries associated with their label.\r\n```\r\n\r\nI tried being more concrete in time (what is \"very long periods of time\"?) and attack (what is \"limited value\"?).",
              "createdAt": "2025-05-22T08:42:03Z",
              "updatedAt": "2025-05-22T12:00:45Z"
            },
            {
              "originalPosition": 85,
              "body": "```suggestion\r\nuint16 CipherSuite;\r\nCipherSuite KT_LVL_HASH_SIG = VALUE;\r\n```\r\n\r\nThink this is clear enough, and shorter.",
              "createdAt": "2025-05-22T08:44:49Z",
              "updatedAt": "2025-05-22T09:02:42Z"
            },
            {
              "originalPosition": 93,
              "body": "```suggestion\r\n- Recommended: Whether support for this cipher suite is RECOMMENDED.\r\n```",
              "createdAt": "2025-05-22T08:46:24Z",
              "updatedAt": "2025-05-22T09:02:42Z"
            },
            {
              "originalPosition": 98,
              "body": "```suggestion\r\n  - Y: Indicates that the item is RECOMMENDED. This\r\n```",
              "createdAt": "2025-05-22T08:46:45Z",
              "updatedAt": "2025-05-22T09:02:42Z"
            },
            {
              "originalPosition": 100,
              "body": "I find this sentence unclear. Which purpose was each mechanism defined for? How does one learn about this purpose?",
              "createdAt": "2025-05-22T08:47:45Z",
              "updatedAt": "2025-05-22T09:02:42Z"
            },
            {
              "originalPosition": 102,
              "body": "Applicability to what?",
              "createdAt": "2025-05-22T08:47:59Z",
              "updatedAt": "2025-05-22T09:02:42Z"
            },
            {
              "originalPosition": 104,
              "body": "```suggestion\r\n    necessary to understand the applicability of that mechanism. Mechanisms with\r\n    limited applicability may be recommended, but in such cases applicability\r\n    statements that describe any limitations of the mechanism or necessary\r\n    constraints will be provided.\r\n```",
              "createdAt": "2025-05-22T08:50:33Z",
              "updatedAt": "2025-05-22T09:02:42Z"
            },
            {
              "originalPosition": 110,
              "body": "```suggestion\r\n  - N: Indicates that the item's associated mechanism has not been evaluated and\r\n    is not RECOMMENDED (as opposed to being NOT RECOMMENDED). This does not\r\n    mean that the mechanism is flawed. For example, an item may be marked as \"N\"\r\n    because it has usage constraints or limited applicability.\r\n```",
              "createdAt": "2025-05-22T08:53:49Z",
              "updatedAt": "2025-05-22T09:02:42Z"
            },
            {
              "originalPosition": 111,
              "body": "So what is it? SHOULD NOT or MUST NOT? Can only be one.",
              "createdAt": "2025-05-22T08:54:16Z",
              "updatedAt": "2025-05-22T09:02:42Z"
            },
            {
              "originalPosition": 114,
              "body": "I find it odd to have a category that must not be used. I think, it would be better to drop this category. Anything that's unspecified cannot be used anyways. One could have an appendix for \"evaluated mechanisms\" that were discarded to document reasoning.",
              "createdAt": "2025-05-22T08:55:11Z",
              "updatedAt": "2025-05-22T09:02:42Z"
            },
            {
              "originalPosition": 126,
              "body": "```suggestion\r\nFor all cipher suites, the following primitives and parameters are the same:\r\n```",
              "createdAt": "2025-05-22T08:56:30Z",
              "updatedAt": "2025-05-22T09:02:42Z"
            },
            {
              "originalPosition": 130,
              "body": "I am puzzled. What does this mean?",
              "createdAt": "2025-05-22T08:57:07Z",
              "updatedAt": "2025-05-22T09:02:42Z"
            },
            {
              "originalPosition": 130,
              "body": "Why not list these explicitly? I think we need not standardize that all ciphersuites must use SHA-256. If we think they should, we should only standardize ciphersuites that do.\r\n\r\nThe difference is whether we standardize that we must or just doing it.",
              "createdAt": "2025-05-22T08:58:34Z",
              "updatedAt": "2025-05-22T09:02:42Z"
            },
            {
              "originalPosition": 143,
              "body": "Oy. This seems like quite the process being standardized here. Has this already been worked towards? This must be carefully discussed before we proceed. I would like to learn more about the requirements for having a \"designated experts\" group etc. Why not just leave it up to the WG?",
              "createdAt": "2025-05-22T09:00:45Z",
              "updatedAt": "2025-05-22T09:02:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrnaA86uPMl9",
          "commit": {
            "abbreviatedOid": "6f2460d"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-13T02:04:56Z",
          "updatedAt": "2025-06-13T02:04:56Z",
          "comments": [
            {
              "originalPosition": 100,
              "body": "The applicability / purpose of a mechanism is specified in an architecture document. So like, the arch document we have for keytrans",
              "createdAt": "2025-06-13T02:04:56Z",
              "updatedAt": "2025-06-13T02:04:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrnaA86uPOA-",
          "commit": {
            "abbreviatedOid": "6f2460d"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-13T02:10:02Z",
          "updatedAt": "2025-06-13T02:10:02Z",
          "comments": [
            {
              "originalPosition": 114,
              "body": "I think the problem is that once IANA allocates a codepoint, it cannot be un-allocated. But we can change whether the codepoint is Y / N / D. So a codepoint might start Y then move to D due to cryptanalysis.",
              "createdAt": "2025-06-13T02:10:02Z",
              "updatedAt": "2025-06-13T02:10:02Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrnaA86uPOSX",
          "commit": {
            "abbreviatedOid": "6f2460d"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-13T02:10:41Z",
          "updatedAt": "2025-06-13T02:10:41Z",
          "comments": [
            {
              "originalPosition": 126,
              "body": "This statement only holds for this document. Other documents may create cipher suites that do something different",
              "createdAt": "2025-06-13T02:10:41Z",
              "updatedAt": "2025-06-13T02:10:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrnaA86uPPS3",
          "commit": {
            "abbreviatedOid": "6f2460d"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-13T02:12:23Z",
          "updatedAt": "2025-06-13T02:12:23Z",
          "comments": [
            {
              "originalPosition": 130,
              "body": "We are not standardizing that all cipher suites must use SHA-256? We are just saying that the two defined here do.",
              "createdAt": "2025-06-13T02:12:23Z",
              "updatedAt": "2025-06-13T02:12:39Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrnaA86uPP5p",
          "commit": {
            "abbreviatedOid": "6f2460d"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-13T02:14:44Z",
          "updatedAt": "2025-06-13T02:14:45Z",
          "comments": [
            {
              "originalPosition": 143,
              "body": "I'm pretty sure it is just a mailing list to approve allocating codepoints. TLS, MLS, etc have them. The keytrans wg may not always exist to make such decisions",
              "createdAt": "2025-06-13T02:14:44Z",
              "updatedAt": "2025-06-13T02:14:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrnaA86usCq9",
          "commit": {
            "abbreviatedOid": "6f2460d"
          },
          "author": "felixlinker",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-16T06:26:59Z",
          "updatedAt": "2025-06-16T06:27:00Z",
          "comments": [
            {
              "originalPosition": 114,
              "body": "Okay, if this is true please mark my comment as resolved! How do we get from \"I think the problem is\" to \"the problem is\"? \ud83d\ude01 ",
              "createdAt": "2025-06-16T06:27:00Z",
              "updatedAt": "2025-06-16T06:27:00Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrnaA86usFHe",
          "commit": {
            "abbreviatedOid": "92cf060"
          },
          "author": "felixlinker",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-16T06:32:08Z",
          "updatedAt": "2025-06-16T06:32:08Z",
          "comments": [
            {
              "originalPosition": 130,
              "body": "Okay, I think I parsed \"for all ciphersuites in this document\" differently. That read normative to me. But I still think it would be clearer if we just made the next table bigger. Would suggest that as a commit, but still don't know really what `Kc` means \ud83d\ude07  (Like, _is it_ `d82...` or is it something that decodes to that?)",
              "createdAt": "2025-06-16T06:32:08Z",
              "updatedAt": "2025-06-16T06:32:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrnaA86usGEm",
          "commit": {
            "abbreviatedOid": "92cf060"
          },
          "author": "felixlinker",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-16T06:34:01Z",
          "updatedAt": "2025-06-16T06:34:01Z",
          "comments": [
            {
              "originalPosition": 143,
              "body": "Okay, if this is a standard thing, that sounds good, but it also seems like quite the administrative hurdle. I wonder whether we could make this simpler initially and standardize a process to \"do things\" later.",
              "createdAt": "2025-06-16T06:34:01Z",
              "updatedAt": "2025-06-16T06:34:01Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLrnaA86usG9X",
          "commit": {
            "abbreviatedOid": "92cf060"
          },
          "author": "felixlinker",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-16T06:35:50Z",
          "updatedAt": "2025-06-16T06:35:50Z",
          "comments": [
            {
              "originalPosition": 100,
              "body": "Okay, but there should be a reference to this, no? I think, an example could already help. Maybe a sentence like: \"For example, some ciphersuites may assume that the log's contents are public, while others aim to keep them private.\"",
              "createdAt": "2025-06-16T06:35:50Z",
              "updatedAt": "2025-06-16T06:35:50Z"
            }
          ]
        }
      ]
    }
  ]
}